# source: http://192.168.99.100:4466
# timestamp: Fri Aug 24 2018 18:00:36 GMT+1200 (New Zealand Standard Time)

type Address implements Node {
  id: ID!
  street: String!
  city: String!
  region: String
  country: String!
}

"""A connection to a list of items."""
type AddressConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [AddressEdge]!
  aggregate: AggregateAddress!
}

input AddressCreateInput {
  street: String!
  city: String!
  region: String
  country: String!
}

input AddressCreateOneInput {
  create: AddressCreateInput
  connect: AddressWhereUniqueInput
}

"""An edge in a connection."""
type AddressEdge {
  """The item at the end of the edge."""
  node: Address!

  """A cursor for use in pagination."""
  cursor: String!
}

enum AddressOrderByInput {
  id_ASC
  id_DESC
  street_ASC
  street_DESC
  city_ASC
  city_DESC
  region_ASC
  region_DESC
  country_ASC
  country_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type AddressPreviousValues {
  id: ID!
  street: String!
  city: String!
  region: String
  country: String!
}

type AddressSubscriptionPayload {
  mutation: MutationType!
  node: Address
  updatedFields: [String!]
  previousValues: AddressPreviousValues
}

input AddressSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [AddressSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [AddressSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [AddressSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AddressWhereInput
}

input AddressUpdateDataInput {
  street: String
  city: String
  region: String
  country: String
}

input AddressUpdateInput {
  street: String
  city: String
  region: String
  country: String
}

input AddressUpdateOneInput {
  create: AddressCreateInput
  connect: AddressWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: AddressUpdateDataInput
  upsert: AddressUpsertNestedInput
}

input AddressUpsertNestedInput {
  update: AddressUpdateDataInput!
  create: AddressCreateInput!
}

input AddressWhereInput {
  """Logical AND on all given filters."""
  AND: [AddressWhereInput!]

  """Logical OR on all given filters."""
  OR: [AddressWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [AddressWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  street: String

  """All values that are not equal to given value."""
  street_not: String

  """All values that are contained in given list."""
  street_in: [String!]

  """All values that are not contained in given list."""
  street_not_in: [String!]

  """All values less than the given value."""
  street_lt: String

  """All values less than or equal the given value."""
  street_lte: String

  """All values greater than the given value."""
  street_gt: String

  """All values greater than or equal the given value."""
  street_gte: String

  """All values containing the given string."""
  street_contains: String

  """All values not containing the given string."""
  street_not_contains: String

  """All values starting with the given string."""
  street_starts_with: String

  """All values not starting with the given string."""
  street_not_starts_with: String

  """All values ending with the given string."""
  street_ends_with: String

  """All values not ending with the given string."""
  street_not_ends_with: String
  city: String

  """All values that are not equal to given value."""
  city_not: String

  """All values that are contained in given list."""
  city_in: [String!]

  """All values that are not contained in given list."""
  city_not_in: [String!]

  """All values less than the given value."""
  city_lt: String

  """All values less than or equal the given value."""
  city_lte: String

  """All values greater than the given value."""
  city_gt: String

  """All values greater than or equal the given value."""
  city_gte: String

  """All values containing the given string."""
  city_contains: String

  """All values not containing the given string."""
  city_not_contains: String

  """All values starting with the given string."""
  city_starts_with: String

  """All values not starting with the given string."""
  city_not_starts_with: String

  """All values ending with the given string."""
  city_ends_with: String

  """All values not ending with the given string."""
  city_not_ends_with: String
  region: String

  """All values that are not equal to given value."""
  region_not: String

  """All values that are contained in given list."""
  region_in: [String!]

  """All values that are not contained in given list."""
  region_not_in: [String!]

  """All values less than the given value."""
  region_lt: String

  """All values less than or equal the given value."""
  region_lte: String

  """All values greater than the given value."""
  region_gt: String

  """All values greater than or equal the given value."""
  region_gte: String

  """All values containing the given string."""
  region_contains: String

  """All values not containing the given string."""
  region_not_contains: String

  """All values starting with the given string."""
  region_starts_with: String

  """All values not starting with the given string."""
  region_not_starts_with: String

  """All values ending with the given string."""
  region_ends_with: String

  """All values not ending with the given string."""
  region_not_ends_with: String
  country: String

  """All values that are not equal to given value."""
  country_not: String

  """All values that are contained in given list."""
  country_in: [String!]

  """All values that are not contained in given list."""
  country_not_in: [String!]

  """All values less than the given value."""
  country_lt: String

  """All values less than or equal the given value."""
  country_lte: String

  """All values greater than the given value."""
  country_gt: String

  """All values greater than or equal the given value."""
  country_gte: String

  """All values containing the given string."""
  country_contains: String

  """All values not containing the given string."""
  country_not_contains: String

  """All values starting with the given string."""
  country_starts_with: String

  """All values not starting with the given string."""
  country_not_starts_with: String

  """All values ending with the given string."""
  country_ends_with: String

  """All values not ending with the given string."""
  country_not_ends_with: String
  _MagicalBackRelation_AddressToProperty_every: PropertyWhereInput
  _MagicalBackRelation_AddressToProperty_some: PropertyWhereInput
  _MagicalBackRelation_AddressToProperty_none: PropertyWhereInput
  _MagicalBackRelation_AddressToCustomer_every: CustomerWhereInput
  _MagicalBackRelation_AddressToCustomer_some: CustomerWhereInput
  _MagicalBackRelation_AddressToCustomer_none: CustomerWhereInput
}

input AddressWhereUniqueInput {
  id: ID
}

type AggregateAddress {
  count: Int!
}

type AggregateBed {
  count: Int!
}

type AggregateBedType {
  count: Int!
}

type AggregateBooking {
  count: Int!
}

type AggregateCategory {
  count: Int!
}

type AggregateCountry {
  count: Int!
}

type AggregateCurrency {
  count: Int!
}

type AggregateCustomer {
  count: Int!
}

type AggregateFacility {
  count: Int!
}

type AggregateFacilityType {
  count: Int!
}

type AggregateLanguage {
  count: Int!
}

type AggregateOrder {
  count: Int!
}

type AggregatePolicy {
  count: Int!
}

type AggregatePreference {
  count: Int!
}

type AggregatePrice {
  count: Int!
}

type AggregatePriceType {
  count: Int!
}

type AggregatePromo {
  count: Int!
}

type AggregateProperty {
  count: Int!
}

type AggregatePropertyFacility {
  count: Int!
}

type AggregateReview {
  count: Int!
}

type AggregateRoom {
  count: Int!
}

type AggregateTax {
  count: Int!
}

type AggregateTimezone {
  count: Int!
}

type BatchPayload {
  """The number of nodes that have been affected by the Batch operation."""
  count: Long!
}

type Bed implements Node {
  id: ID!
  quantity: Int!
  type(where: BedTypeWhereInput): BedType!
  rooms(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Room!]
}

"""A connection to a list of items."""
type BedConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [BedEdge]!
  aggregate: AggregateBed!
}

input BedCreateInput {
  quantity: Int!
  type: BedTypeCreateOneWithoutBedsInput!
  rooms: RoomCreateManyWithoutBedsInput
}

input BedCreateManyWithoutRoomsInput {
  create: [BedCreateWithoutRoomsInput!]
  connect: [BedWhereUniqueInput!]
}

input BedCreateManyWithoutTypeInput {
  create: [BedCreateWithoutTypeInput!]
  connect: [BedWhereUniqueInput!]
}

input BedCreateWithoutRoomsInput {
  quantity: Int!
  type: BedTypeCreateOneWithoutBedsInput!
}

input BedCreateWithoutTypeInput {
  quantity: Int!
  rooms: RoomCreateManyWithoutBedsInput
}

"""An edge in a connection."""
type BedEdge {
  """The item at the end of the edge."""
  node: Bed!

  """A cursor for use in pagination."""
  cursor: String!
}

enum BedOrderByInput {
  id_ASC
  id_DESC
  quantity_ASC
  quantity_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BedPreviousValues {
  id: ID!
  quantity: Int!
}

type BedSubscriptionPayload {
  mutation: MutationType!
  node: Bed
  updatedFields: [String!]
  previousValues: BedPreviousValues
}

input BedSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [BedSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [BedSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BedSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BedWhereInput
}

type BedType implements Node {
  id: ID!
  name: String!
  beds(where: BedWhereInput, orderBy: BedOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Bed!]
}

"""A connection to a list of items."""
type BedTypeConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [BedTypeEdge]!
  aggregate: AggregateBedType!
}

input BedTypeCreateInput {
  name: String!
  beds: BedCreateManyWithoutTypeInput
}

input BedTypeCreateOneWithoutBedsInput {
  create: BedTypeCreateWithoutBedsInput
  connect: BedTypeWhereUniqueInput
}

input BedTypeCreateWithoutBedsInput {
  name: String!
}

"""An edge in a connection."""
type BedTypeEdge {
  """The item at the end of the edge."""
  node: BedType!

  """A cursor for use in pagination."""
  cursor: String!
}

enum BedTypeOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BedTypePreviousValues {
  id: ID!
  name: String!
}

type BedTypeSubscriptionPayload {
  mutation: MutationType!
  node: BedType
  updatedFields: [String!]
  previousValues: BedTypePreviousValues
}

input BedTypeSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [BedTypeSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [BedTypeSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BedTypeSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BedTypeWhereInput
}

input BedTypeUpdateInput {
  name: String
  beds: BedUpdateManyWithoutTypeInput
}

input BedTypeUpdateOneWithoutBedsInput {
  create: BedTypeCreateWithoutBedsInput
  connect: BedTypeWhereUniqueInput
  delete: Boolean
  update: BedTypeUpdateWithoutBedsDataInput
  upsert: BedTypeUpsertWithoutBedsInput
}

input BedTypeUpdateWithoutBedsDataInput {
  name: String
}

input BedTypeUpsertWithoutBedsInput {
  update: BedTypeUpdateWithoutBedsDataInput!
  create: BedTypeCreateWithoutBedsInput!
}

input BedTypeWhereInput {
  """Logical AND on all given filters."""
  AND: [BedTypeWhereInput!]

  """Logical OR on all given filters."""
  OR: [BedTypeWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BedTypeWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  beds_every: BedWhereInput
  beds_some: BedWhereInput
  beds_none: BedWhereInput
}

input BedTypeWhereUniqueInput {
  id: ID
  name: String
}

input BedUpdateInput {
  quantity: Int
  type: BedTypeUpdateOneWithoutBedsInput
  rooms: RoomUpdateManyWithoutBedsInput
}

input BedUpdateManyWithoutRoomsInput {
  create: [BedCreateWithoutRoomsInput!]
  connect: [BedWhereUniqueInput!]
  disconnect: [BedWhereUniqueInput!]
  delete: [BedWhereUniqueInput!]
  update: [BedUpdateWithWhereUniqueWithoutRoomsInput!]
  upsert: [BedUpsertWithWhereUniqueWithoutRoomsInput!]
}

input BedUpdateManyWithoutTypeInput {
  create: [BedCreateWithoutTypeInput!]
  connect: [BedWhereUniqueInput!]
  disconnect: [BedWhereUniqueInput!]
  delete: [BedWhereUniqueInput!]
  update: [BedUpdateWithWhereUniqueWithoutTypeInput!]
  upsert: [BedUpsertWithWhereUniqueWithoutTypeInput!]
}

input BedUpdateWithoutRoomsDataInput {
  quantity: Int
  type: BedTypeUpdateOneWithoutBedsInput
}

input BedUpdateWithoutTypeDataInput {
  quantity: Int
  rooms: RoomUpdateManyWithoutBedsInput
}

input BedUpdateWithWhereUniqueWithoutRoomsInput {
  where: BedWhereUniqueInput!
  data: BedUpdateWithoutRoomsDataInput!
}

input BedUpdateWithWhereUniqueWithoutTypeInput {
  where: BedWhereUniqueInput!
  data: BedUpdateWithoutTypeDataInput!
}

input BedUpsertWithWhereUniqueWithoutRoomsInput {
  where: BedWhereUniqueInput!
  update: BedUpdateWithoutRoomsDataInput!
  create: BedCreateWithoutRoomsInput!
}

input BedUpsertWithWhereUniqueWithoutTypeInput {
  where: BedWhereUniqueInput!
  update: BedUpdateWithoutTypeDataInput!
  create: BedCreateWithoutTypeInput!
}

input BedWhereInput {
  """Logical AND on all given filters."""
  AND: [BedWhereInput!]

  """Logical OR on all given filters."""
  OR: [BedWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BedWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  quantity: Int

  """All values that are not equal to given value."""
  quantity_not: Int

  """All values that are contained in given list."""
  quantity_in: [Int!]

  """All values that are not contained in given list."""
  quantity_not_in: [Int!]

  """All values less than the given value."""
  quantity_lt: Int

  """All values less than or equal the given value."""
  quantity_lte: Int

  """All values greater than the given value."""
  quantity_gt: Int

  """All values greater than or equal the given value."""
  quantity_gte: Int
  type: BedTypeWhereInput
  rooms_every: RoomWhereInput
  rooms_some: RoomWhereInput
  rooms_none: RoomWhereInput
}

input BedWhereUniqueInput {
  id: ID
}

type Booking implements Node {
  id: ID!
  guest(where: CustomerWhereInput): Customer!
  rooms(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Room!]
  startDate: DateTime!
  endDate: DateTime!
  numberOfGuests: Int
}

"""A connection to a list of items."""
type BookingConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [BookingEdge]!
  aggregate: AggregateBooking!
}

input BookingCreateInput {
  startDate: DateTime!
  endDate: DateTime!
  numberOfGuests: Int
  guest: CustomerCreateOneWithoutBookingsInput!
  rooms: RoomCreateManyWithoutBookingsInput
}

input BookingCreateManyWithoutGuestInput {
  create: [BookingCreateWithoutGuestInput!]
  connect: [BookingWhereUniqueInput!]
}

input BookingCreateManyWithoutRoomsInput {
  create: [BookingCreateWithoutRoomsInput!]
  connect: [BookingWhereUniqueInput!]
}

input BookingCreateOneInput {
  create: BookingCreateInput
  connect: BookingWhereUniqueInput
}

input BookingCreateWithoutGuestInput {
  startDate: DateTime!
  endDate: DateTime!
  numberOfGuests: Int
  rooms: RoomCreateManyWithoutBookingsInput
}

input BookingCreateWithoutRoomsInput {
  startDate: DateTime!
  endDate: DateTime!
  numberOfGuests: Int
  guest: CustomerCreateOneWithoutBookingsInput!
}

"""An edge in a connection."""
type BookingEdge {
  """The item at the end of the edge."""
  node: Booking!

  """A cursor for use in pagination."""
  cursor: String!
}

enum BookingOrderByInput {
  id_ASC
  id_DESC
  startDate_ASC
  startDate_DESC
  endDate_ASC
  endDate_DESC
  numberOfGuests_ASC
  numberOfGuests_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BookingPreviousValues {
  id: ID!
  startDate: DateTime!
  endDate: DateTime!
  numberOfGuests: Int
}

type BookingSubscriptionPayload {
  mutation: MutationType!
  node: Booking
  updatedFields: [String!]
  previousValues: BookingPreviousValues
}

input BookingSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [BookingSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [BookingSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BookingSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: BookingWhereInput
}

input BookingUpdateDataInput {
  startDate: DateTime
  endDate: DateTime
  numberOfGuests: Int
  guest: CustomerUpdateOneWithoutBookingsInput
  rooms: RoomUpdateManyWithoutBookingsInput
}

input BookingUpdateInput {
  startDate: DateTime
  endDate: DateTime
  numberOfGuests: Int
  guest: CustomerUpdateOneWithoutBookingsInput
  rooms: RoomUpdateManyWithoutBookingsInput
}

input BookingUpdateManyWithoutGuestInput {
  create: [BookingCreateWithoutGuestInput!]
  connect: [BookingWhereUniqueInput!]
  disconnect: [BookingWhereUniqueInput!]
  delete: [BookingWhereUniqueInput!]
  update: [BookingUpdateWithWhereUniqueWithoutGuestInput!]
  upsert: [BookingUpsertWithWhereUniqueWithoutGuestInput!]
}

input BookingUpdateManyWithoutRoomsInput {
  create: [BookingCreateWithoutRoomsInput!]
  connect: [BookingWhereUniqueInput!]
  disconnect: [BookingWhereUniqueInput!]
  delete: [BookingWhereUniqueInput!]
  update: [BookingUpdateWithWhereUniqueWithoutRoomsInput!]
  upsert: [BookingUpsertWithWhereUniqueWithoutRoomsInput!]
}

input BookingUpdateOneInput {
  create: BookingCreateInput
  connect: BookingWhereUniqueInput
  delete: Boolean
  update: BookingUpdateDataInput
  upsert: BookingUpsertNestedInput
}

input BookingUpdateWithoutGuestDataInput {
  startDate: DateTime
  endDate: DateTime
  numberOfGuests: Int
  rooms: RoomUpdateManyWithoutBookingsInput
}

input BookingUpdateWithoutRoomsDataInput {
  startDate: DateTime
  endDate: DateTime
  numberOfGuests: Int
  guest: CustomerUpdateOneWithoutBookingsInput
}

input BookingUpdateWithWhereUniqueWithoutGuestInput {
  where: BookingWhereUniqueInput!
  data: BookingUpdateWithoutGuestDataInput!
}

input BookingUpdateWithWhereUniqueWithoutRoomsInput {
  where: BookingWhereUniqueInput!
  data: BookingUpdateWithoutRoomsDataInput!
}

input BookingUpsertNestedInput {
  update: BookingUpdateDataInput!
  create: BookingCreateInput!
}

input BookingUpsertWithWhereUniqueWithoutGuestInput {
  where: BookingWhereUniqueInput!
  update: BookingUpdateWithoutGuestDataInput!
  create: BookingCreateWithoutGuestInput!
}

input BookingUpsertWithWhereUniqueWithoutRoomsInput {
  where: BookingWhereUniqueInput!
  update: BookingUpdateWithoutRoomsDataInput!
  create: BookingCreateWithoutRoomsInput!
}

input BookingWhereInput {
  """Logical AND on all given filters."""
  AND: [BookingWhereInput!]

  """Logical OR on all given filters."""
  OR: [BookingWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [BookingWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  startDate: DateTime

  """All values that are not equal to given value."""
  startDate_not: DateTime

  """All values that are contained in given list."""
  startDate_in: [DateTime!]

  """All values that are not contained in given list."""
  startDate_not_in: [DateTime!]

  """All values less than the given value."""
  startDate_lt: DateTime

  """All values less than or equal the given value."""
  startDate_lte: DateTime

  """All values greater than the given value."""
  startDate_gt: DateTime

  """All values greater than or equal the given value."""
  startDate_gte: DateTime
  endDate: DateTime

  """All values that are not equal to given value."""
  endDate_not: DateTime

  """All values that are contained in given list."""
  endDate_in: [DateTime!]

  """All values that are not contained in given list."""
  endDate_not_in: [DateTime!]

  """All values less than the given value."""
  endDate_lt: DateTime

  """All values less than or equal the given value."""
  endDate_lte: DateTime

  """All values greater than the given value."""
  endDate_gt: DateTime

  """All values greater than or equal the given value."""
  endDate_gte: DateTime
  numberOfGuests: Int

  """All values that are not equal to given value."""
  numberOfGuests_not: Int

  """All values that are contained in given list."""
  numberOfGuests_in: [Int!]

  """All values that are not contained in given list."""
  numberOfGuests_not_in: [Int!]

  """All values less than the given value."""
  numberOfGuests_lt: Int

  """All values less than or equal the given value."""
  numberOfGuests_lte: Int

  """All values greater than the given value."""
  numberOfGuests_gt: Int

  """All values greater than or equal the given value."""
  numberOfGuests_gte: Int
  guest: CustomerWhereInput
  rooms_every: RoomWhereInput
  rooms_some: RoomWhereInput
  rooms_none: RoomWhereInput
  _MagicalBackRelation_BookingToOrder_every: OrderWhereInput
  _MagicalBackRelation_BookingToOrder_some: OrderWhereInput
  _MagicalBackRelation_BookingToOrder_none: OrderWhereInput
}

input BookingWhereUniqueInput {
  id: ID
}

type Category implements Node {
  id: ID!
  name: String!
  properties(where: PropertyWhereInput, orderBy: PropertyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Property!]
}

"""A connection to a list of items."""
type CategoryConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CategoryEdge]!
  aggregate: AggregateCategory!
}

input CategoryCreateInput {
  name: String!
  properties: PropertyCreateManyWithoutCategoriesInput
}

input CategoryCreateManyWithoutPropertiesInput {
  create: [CategoryCreateWithoutPropertiesInput!]
  connect: [CategoryWhereUniqueInput!]
}

input CategoryCreateWithoutPropertiesInput {
  name: String!
}

"""An edge in a connection."""
type CategoryEdge {
  """The item at the end of the edge."""
  node: Category!

  """A cursor for use in pagination."""
  cursor: String!
}

enum CategoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CategoryPreviousValues {
  id: ID!
  name: String!
}

type CategorySubscriptionPayload {
  mutation: MutationType!
  node: Category
  updatedFields: [String!]
  previousValues: CategoryPreviousValues
}

input CategorySubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [CategorySubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [CategorySubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CategorySubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CategoryWhereInput
}

input CategoryUpdateInput {
  name: String
  properties: PropertyUpdateManyWithoutCategoriesInput
}

input CategoryUpdateManyWithoutPropertiesInput {
  create: [CategoryCreateWithoutPropertiesInput!]
  connect: [CategoryWhereUniqueInput!]
  disconnect: [CategoryWhereUniqueInput!]
  delete: [CategoryWhereUniqueInput!]
  update: [CategoryUpdateWithWhereUniqueWithoutPropertiesInput!]
  upsert: [CategoryUpsertWithWhereUniqueWithoutPropertiesInput!]
}

input CategoryUpdateWithoutPropertiesDataInput {
  name: String
}

input CategoryUpdateWithWhereUniqueWithoutPropertiesInput {
  where: CategoryWhereUniqueInput!
  data: CategoryUpdateWithoutPropertiesDataInput!
}

input CategoryUpsertWithWhereUniqueWithoutPropertiesInput {
  where: CategoryWhereUniqueInput!
  update: CategoryUpdateWithoutPropertiesDataInput!
  create: CategoryCreateWithoutPropertiesInput!
}

input CategoryWhereInput {
  """Logical AND on all given filters."""
  AND: [CategoryWhereInput!]

  """Logical OR on all given filters."""
  OR: [CategoryWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CategoryWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  properties_every: PropertyWhereInput
  properties_some: PropertyWhereInput
  properties_none: PropertyWhereInput
}

input CategoryWhereUniqueInput {
  id: ID
  name: String
}

type Country implements Node {
  id: ID!
  name: String!
  currency(where: CurrencyWhereInput): Currency!
  timezone(where: TimezoneWhereInput): Timezone
  languages(where: LanguageWhereInput, orderBy: LanguageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Language!]
}

"""A connection to a list of items."""
type CountryConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CountryEdge]!
  aggregate: AggregateCountry!
}

input CountryCreateInput {
  name: String!
  currency: CurrencyCreateOneWithoutCountryInput!
  timezone: TimezoneCreateOneWithoutCountryInput
  languages: LanguageCreateManyWithoutCountriesInput
}

input CountryCreateManyWithoutLanguagesInput {
  create: [CountryCreateWithoutLanguagesInput!]
  connect: [CountryWhereUniqueInput!]
}

input CountryCreateOneInput {
  create: CountryCreateInput
  connect: CountryWhereUniqueInput
}

input CountryCreateOneWithoutCurrencyInput {
  create: CountryCreateWithoutCurrencyInput
  connect: CountryWhereUniqueInput
}

input CountryCreateOneWithoutTimezoneInput {
  create: CountryCreateWithoutTimezoneInput
  connect: CountryWhereUniqueInput
}

input CountryCreateWithoutCurrencyInput {
  name: String!
  timezone: TimezoneCreateOneWithoutCountryInput
  languages: LanguageCreateManyWithoutCountriesInput
}

input CountryCreateWithoutLanguagesInput {
  name: String!
  currency: CurrencyCreateOneWithoutCountryInput!
  timezone: TimezoneCreateOneWithoutCountryInput
}

input CountryCreateWithoutTimezoneInput {
  name: String!
  currency: CurrencyCreateOneWithoutCountryInput!
  languages: LanguageCreateManyWithoutCountriesInput
}

"""An edge in a connection."""
type CountryEdge {
  """The item at the end of the edge."""
  node: Country!

  """A cursor for use in pagination."""
  cursor: String!
}

enum CountryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CountryPreviousValues {
  id: ID!
  name: String!
}

type CountrySubscriptionPayload {
  mutation: MutationType!
  node: Country
  updatedFields: [String!]
  previousValues: CountryPreviousValues
}

input CountrySubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [CountrySubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [CountrySubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CountrySubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CountryWhereInput
}

input CountryUpdateDataInput {
  name: String
  currency: CurrencyUpdateOneWithoutCountryInput
  timezone: TimezoneUpdateOneWithoutCountryInput
  languages: LanguageUpdateManyWithoutCountriesInput
}

input CountryUpdateInput {
  name: String
  currency: CurrencyUpdateOneWithoutCountryInput
  timezone: TimezoneUpdateOneWithoutCountryInput
  languages: LanguageUpdateManyWithoutCountriesInput
}

input CountryUpdateManyWithoutLanguagesInput {
  create: [CountryCreateWithoutLanguagesInput!]
  connect: [CountryWhereUniqueInput!]
  disconnect: [CountryWhereUniqueInput!]
  delete: [CountryWhereUniqueInput!]
  update: [CountryUpdateWithWhereUniqueWithoutLanguagesInput!]
  upsert: [CountryUpsertWithWhereUniqueWithoutLanguagesInput!]
}

input CountryUpdateOneInput {
  create: CountryCreateInput
  connect: CountryWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: CountryUpdateDataInput
  upsert: CountryUpsertNestedInput
}

input CountryUpdateOneWithoutCurrencyInput {
  create: CountryCreateWithoutCurrencyInput
  connect: CountryWhereUniqueInput
  delete: Boolean
  update: CountryUpdateWithoutCurrencyDataInput
  upsert: CountryUpsertWithoutCurrencyInput
}

input CountryUpdateOneWithoutTimezoneInput {
  create: CountryCreateWithoutTimezoneInput
  connect: CountryWhereUniqueInput
  delete: Boolean
  update: CountryUpdateWithoutTimezoneDataInput
  upsert: CountryUpsertWithoutTimezoneInput
}

input CountryUpdateWithoutCurrencyDataInput {
  name: String
  timezone: TimezoneUpdateOneWithoutCountryInput
  languages: LanguageUpdateManyWithoutCountriesInput
}

input CountryUpdateWithoutLanguagesDataInput {
  name: String
  currency: CurrencyUpdateOneWithoutCountryInput
  timezone: TimezoneUpdateOneWithoutCountryInput
}

input CountryUpdateWithoutTimezoneDataInput {
  name: String
  currency: CurrencyUpdateOneWithoutCountryInput
  languages: LanguageUpdateManyWithoutCountriesInput
}

input CountryUpdateWithWhereUniqueWithoutLanguagesInput {
  where: CountryWhereUniqueInput!
  data: CountryUpdateWithoutLanguagesDataInput!
}

input CountryUpsertNestedInput {
  update: CountryUpdateDataInput!
  create: CountryCreateInput!
}

input CountryUpsertWithoutCurrencyInput {
  update: CountryUpdateWithoutCurrencyDataInput!
  create: CountryCreateWithoutCurrencyInput!
}

input CountryUpsertWithoutTimezoneInput {
  update: CountryUpdateWithoutTimezoneDataInput!
  create: CountryCreateWithoutTimezoneInput!
}

input CountryUpsertWithWhereUniqueWithoutLanguagesInput {
  where: CountryWhereUniqueInput!
  update: CountryUpdateWithoutLanguagesDataInput!
  create: CountryCreateWithoutLanguagesInput!
}

input CountryWhereInput {
  """Logical AND on all given filters."""
  AND: [CountryWhereInput!]

  """Logical OR on all given filters."""
  OR: [CountryWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CountryWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  currency: CurrencyWhereInput
  timezone: TimezoneWhereInput
  languages_every: LanguageWhereInput
  languages_some: LanguageWhereInput
  languages_none: LanguageWhereInput
  _MagicalBackRelation_CountryToPreference_every: PreferenceWhereInput
  _MagicalBackRelation_CountryToPreference_some: PreferenceWhereInput
  _MagicalBackRelation_CountryToPreference_none: PreferenceWhereInput
}

input CountryWhereUniqueInput {
  id: ID
  name: String
}

type Currency implements Node {
  id: ID!
  symbol: String!
  name: String!
  name_plural: String!
  country(where: CountryWhereInput): Country!
}

"""A connection to a list of items."""
type CurrencyConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CurrencyEdge]!
  aggregate: AggregateCurrency!
}

input CurrencyCreateInput {
  symbol: String!
  name: String!
  name_plural: String!
  country: CountryCreateOneWithoutCurrencyInput!
}

input CurrencyCreateOneInput {
  create: CurrencyCreateInput
  connect: CurrencyWhereUniqueInput
}

input CurrencyCreateOneWithoutCountryInput {
  create: CurrencyCreateWithoutCountryInput
  connect: CurrencyWhereUniqueInput
}

input CurrencyCreateWithoutCountryInput {
  symbol: String!
  name: String!
  name_plural: String!
}

"""An edge in a connection."""
type CurrencyEdge {
  """The item at the end of the edge."""
  node: Currency!

  """A cursor for use in pagination."""
  cursor: String!
}

enum CurrencyOrderByInput {
  id_ASC
  id_DESC
  symbol_ASC
  symbol_DESC
  name_ASC
  name_DESC
  name_plural_ASC
  name_plural_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CurrencyPreviousValues {
  id: ID!
  symbol: String!
  name: String!
  name_plural: String!
}

type CurrencySubscriptionPayload {
  mutation: MutationType!
  node: Currency
  updatedFields: [String!]
  previousValues: CurrencyPreviousValues
}

input CurrencySubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [CurrencySubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [CurrencySubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CurrencySubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CurrencyWhereInput
}

input CurrencyUpdateDataInput {
  symbol: String
  name: String
  name_plural: String
  country: CountryUpdateOneWithoutCurrencyInput
}

input CurrencyUpdateInput {
  symbol: String
  name: String
  name_plural: String
  country: CountryUpdateOneWithoutCurrencyInput
}

input CurrencyUpdateOneInput {
  create: CurrencyCreateInput
  connect: CurrencyWhereUniqueInput
  delete: Boolean
  update: CurrencyUpdateDataInput
  upsert: CurrencyUpsertNestedInput
}

input CurrencyUpdateOneWithoutCountryInput {
  create: CurrencyCreateWithoutCountryInput
  connect: CurrencyWhereUniqueInput
  delete: Boolean
  update: CurrencyUpdateWithoutCountryDataInput
  upsert: CurrencyUpsertWithoutCountryInput
}

input CurrencyUpdateWithoutCountryDataInput {
  symbol: String
  name: String
  name_plural: String
}

input CurrencyUpsertNestedInput {
  update: CurrencyUpdateDataInput!
  create: CurrencyCreateInput!
}

input CurrencyUpsertWithoutCountryInput {
  update: CurrencyUpdateWithoutCountryDataInput!
  create: CurrencyCreateWithoutCountryInput!
}

input CurrencyWhereInput {
  """Logical AND on all given filters."""
  AND: [CurrencyWhereInput!]

  """Logical OR on all given filters."""
  OR: [CurrencyWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CurrencyWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  symbol: String

  """All values that are not equal to given value."""
  symbol_not: String

  """All values that are contained in given list."""
  symbol_in: [String!]

  """All values that are not contained in given list."""
  symbol_not_in: [String!]

  """All values less than the given value."""
  symbol_lt: String

  """All values less than or equal the given value."""
  symbol_lte: String

  """All values greater than the given value."""
  symbol_gt: String

  """All values greater than or equal the given value."""
  symbol_gte: String

  """All values containing the given string."""
  symbol_contains: String

  """All values not containing the given string."""
  symbol_not_contains: String

  """All values starting with the given string."""
  symbol_starts_with: String

  """All values not starting with the given string."""
  symbol_not_starts_with: String

  """All values ending with the given string."""
  symbol_ends_with: String

  """All values not ending with the given string."""
  symbol_not_ends_with: String
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  name_plural: String

  """All values that are not equal to given value."""
  name_plural_not: String

  """All values that are contained in given list."""
  name_plural_in: [String!]

  """All values that are not contained in given list."""
  name_plural_not_in: [String!]

  """All values less than the given value."""
  name_plural_lt: String

  """All values less than or equal the given value."""
  name_plural_lte: String

  """All values greater than the given value."""
  name_plural_gt: String

  """All values greater than or equal the given value."""
  name_plural_gte: String

  """All values containing the given string."""
  name_plural_contains: String

  """All values not containing the given string."""
  name_plural_not_contains: String

  """All values starting with the given string."""
  name_plural_starts_with: String

  """All values not starting with the given string."""
  name_plural_not_starts_with: String

  """All values ending with the given string."""
  name_plural_ends_with: String

  """All values not ending with the given string."""
  name_plural_not_ends_with: String
  country: CountryWhereInput
  _MagicalBackRelation_CurrencyToPrice_every: PriceWhereInput
  _MagicalBackRelation_CurrencyToPrice_some: PriceWhereInput
  _MagicalBackRelation_CurrencyToPrice_none: PriceWhereInput
}

input CurrencyWhereUniqueInput {
  id: ID
  name: String
}

type Customer implements Node {
  id: ID!
  name: String
  email: String!
  password: String!
  phone: String
  address(where: AddressWhereInput): Address
  reviews(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Review!]
  bookings(where: BookingWhereInput, orderBy: BookingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Booking!]
  likedReviews(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Review!]
  dislikedReviews(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Review!]
  properties(where: PropertyWhereInput, orderBy: PropertyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Property!]
  preference(where: PreferenceWhereInput): Preference
}

"""A connection to a list of items."""
type CustomerConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CustomerEdge]!
  aggregate: AggregateCustomer!
}

input CustomerCreateInput {
  name: String
  email: String!
  password: String!
  phone: String
  address: AddressCreateOneInput
  reviews: ReviewCreateManyWithoutByInput
  bookings: BookingCreateManyWithoutGuestInput
  likedReviews: ReviewCreateManyWithoutUpVotesInput
  dislikedReviews: ReviewCreateManyWithoutDownVotesInput
  properties: PropertyCreateManyWithoutOwnerInput
  preference: PreferenceCreateOneWithoutCustomerInput
}

input CustomerCreateManyWithoutDislikedReviewsInput {
  create: [CustomerCreateWithoutDislikedReviewsInput!]
  connect: [CustomerWhereUniqueInput!]
}

input CustomerCreateManyWithoutLikedReviewsInput {
  create: [CustomerCreateWithoutLikedReviewsInput!]
  connect: [CustomerWhereUniqueInput!]
}

input CustomerCreateOneWithoutBookingsInput {
  create: CustomerCreateWithoutBookingsInput
  connect: CustomerWhereUniqueInput
}

input CustomerCreateOneWithoutPreferenceInput {
  create: CustomerCreateWithoutPreferenceInput
  connect: CustomerWhereUniqueInput
}

input CustomerCreateOneWithoutPropertiesInput {
  create: CustomerCreateWithoutPropertiesInput
  connect: CustomerWhereUniqueInput
}

input CustomerCreateOneWithoutReviewsInput {
  create: CustomerCreateWithoutReviewsInput
  connect: CustomerWhereUniqueInput
}

input CustomerCreateWithoutBookingsInput {
  name: String
  email: String!
  password: String!
  phone: String
  address: AddressCreateOneInput
  reviews: ReviewCreateManyWithoutByInput
  likedReviews: ReviewCreateManyWithoutUpVotesInput
  dislikedReviews: ReviewCreateManyWithoutDownVotesInput
  properties: PropertyCreateManyWithoutOwnerInput
  preference: PreferenceCreateOneWithoutCustomerInput
}

input CustomerCreateWithoutDislikedReviewsInput {
  name: String
  email: String!
  password: String!
  phone: String
  address: AddressCreateOneInput
  reviews: ReviewCreateManyWithoutByInput
  bookings: BookingCreateManyWithoutGuestInput
  likedReviews: ReviewCreateManyWithoutUpVotesInput
  properties: PropertyCreateManyWithoutOwnerInput
  preference: PreferenceCreateOneWithoutCustomerInput
}

input CustomerCreateWithoutLikedReviewsInput {
  name: String
  email: String!
  password: String!
  phone: String
  address: AddressCreateOneInput
  reviews: ReviewCreateManyWithoutByInput
  bookings: BookingCreateManyWithoutGuestInput
  dislikedReviews: ReviewCreateManyWithoutDownVotesInput
  properties: PropertyCreateManyWithoutOwnerInput
  preference: PreferenceCreateOneWithoutCustomerInput
}

input CustomerCreateWithoutPreferenceInput {
  name: String
  email: String!
  password: String!
  phone: String
  address: AddressCreateOneInput
  reviews: ReviewCreateManyWithoutByInput
  bookings: BookingCreateManyWithoutGuestInput
  likedReviews: ReviewCreateManyWithoutUpVotesInput
  dislikedReviews: ReviewCreateManyWithoutDownVotesInput
  properties: PropertyCreateManyWithoutOwnerInput
}

input CustomerCreateWithoutPropertiesInput {
  name: String
  email: String!
  password: String!
  phone: String
  address: AddressCreateOneInput
  reviews: ReviewCreateManyWithoutByInput
  bookings: BookingCreateManyWithoutGuestInput
  likedReviews: ReviewCreateManyWithoutUpVotesInput
  dislikedReviews: ReviewCreateManyWithoutDownVotesInput
  preference: PreferenceCreateOneWithoutCustomerInput
}

input CustomerCreateWithoutReviewsInput {
  name: String
  email: String!
  password: String!
  phone: String
  address: AddressCreateOneInput
  bookings: BookingCreateManyWithoutGuestInput
  likedReviews: ReviewCreateManyWithoutUpVotesInput
  dislikedReviews: ReviewCreateManyWithoutDownVotesInput
  properties: PropertyCreateManyWithoutOwnerInput
  preference: PreferenceCreateOneWithoutCustomerInput
}

"""An edge in a connection."""
type CustomerEdge {
  """The item at the end of the edge."""
  node: Customer!

  """A cursor for use in pagination."""
  cursor: String!
}

enum CustomerOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  phone_ASC
  phone_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CustomerPreviousValues {
  id: ID!
  name: String
  email: String!
  password: String!
  phone: String
}

type CustomerSubscriptionPayload {
  mutation: MutationType!
  node: Customer
  updatedFields: [String!]
  previousValues: CustomerPreviousValues
}

input CustomerSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [CustomerSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [CustomerSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CustomerSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CustomerWhereInput
}

input CustomerUpdateInput {
  name: String
  email: String
  password: String
  phone: String
  address: AddressUpdateOneInput
  reviews: ReviewUpdateManyWithoutByInput
  bookings: BookingUpdateManyWithoutGuestInput
  likedReviews: ReviewUpdateManyWithoutUpVotesInput
  dislikedReviews: ReviewUpdateManyWithoutDownVotesInput
  properties: PropertyUpdateManyWithoutOwnerInput
  preference: PreferenceUpdateOneWithoutCustomerInput
}

input CustomerUpdateManyWithoutDislikedReviewsInput {
  create: [CustomerCreateWithoutDislikedReviewsInput!]
  connect: [CustomerWhereUniqueInput!]
  disconnect: [CustomerWhereUniqueInput!]
  delete: [CustomerWhereUniqueInput!]
  update: [CustomerUpdateWithWhereUniqueWithoutDislikedReviewsInput!]
  upsert: [CustomerUpsertWithWhereUniqueWithoutDislikedReviewsInput!]
}

input CustomerUpdateManyWithoutLikedReviewsInput {
  create: [CustomerCreateWithoutLikedReviewsInput!]
  connect: [CustomerWhereUniqueInput!]
  disconnect: [CustomerWhereUniqueInput!]
  delete: [CustomerWhereUniqueInput!]
  update: [CustomerUpdateWithWhereUniqueWithoutLikedReviewsInput!]
  upsert: [CustomerUpsertWithWhereUniqueWithoutLikedReviewsInput!]
}

input CustomerUpdateOneWithoutBookingsInput {
  create: CustomerCreateWithoutBookingsInput
  connect: CustomerWhereUniqueInput
  delete: Boolean
  update: CustomerUpdateWithoutBookingsDataInput
  upsert: CustomerUpsertWithoutBookingsInput
}

input CustomerUpdateOneWithoutPreferenceInput {
  create: CustomerCreateWithoutPreferenceInput
  connect: CustomerWhereUniqueInput
  delete: Boolean
  update: CustomerUpdateWithoutPreferenceDataInput
  upsert: CustomerUpsertWithoutPreferenceInput
}

input CustomerUpdateOneWithoutPropertiesInput {
  create: CustomerCreateWithoutPropertiesInput
  connect: CustomerWhereUniqueInput
  delete: Boolean
  update: CustomerUpdateWithoutPropertiesDataInput
  upsert: CustomerUpsertWithoutPropertiesInput
}

input CustomerUpdateOneWithoutReviewsInput {
  create: CustomerCreateWithoutReviewsInput
  connect: CustomerWhereUniqueInput
  delete: Boolean
  update: CustomerUpdateWithoutReviewsDataInput
  upsert: CustomerUpsertWithoutReviewsInput
}

input CustomerUpdateWithoutBookingsDataInput {
  name: String
  email: String
  password: String
  phone: String
  address: AddressUpdateOneInput
  reviews: ReviewUpdateManyWithoutByInput
  likedReviews: ReviewUpdateManyWithoutUpVotesInput
  dislikedReviews: ReviewUpdateManyWithoutDownVotesInput
  properties: PropertyUpdateManyWithoutOwnerInput
  preference: PreferenceUpdateOneWithoutCustomerInput
}

input CustomerUpdateWithoutDislikedReviewsDataInput {
  name: String
  email: String
  password: String
  phone: String
  address: AddressUpdateOneInput
  reviews: ReviewUpdateManyWithoutByInput
  bookings: BookingUpdateManyWithoutGuestInput
  likedReviews: ReviewUpdateManyWithoutUpVotesInput
  properties: PropertyUpdateManyWithoutOwnerInput
  preference: PreferenceUpdateOneWithoutCustomerInput
}

input CustomerUpdateWithoutLikedReviewsDataInput {
  name: String
  email: String
  password: String
  phone: String
  address: AddressUpdateOneInput
  reviews: ReviewUpdateManyWithoutByInput
  bookings: BookingUpdateManyWithoutGuestInput
  dislikedReviews: ReviewUpdateManyWithoutDownVotesInput
  properties: PropertyUpdateManyWithoutOwnerInput
  preference: PreferenceUpdateOneWithoutCustomerInput
}

input CustomerUpdateWithoutPreferenceDataInput {
  name: String
  email: String
  password: String
  phone: String
  address: AddressUpdateOneInput
  reviews: ReviewUpdateManyWithoutByInput
  bookings: BookingUpdateManyWithoutGuestInput
  likedReviews: ReviewUpdateManyWithoutUpVotesInput
  dislikedReviews: ReviewUpdateManyWithoutDownVotesInput
  properties: PropertyUpdateManyWithoutOwnerInput
}

input CustomerUpdateWithoutPropertiesDataInput {
  name: String
  email: String
  password: String
  phone: String
  address: AddressUpdateOneInput
  reviews: ReviewUpdateManyWithoutByInput
  bookings: BookingUpdateManyWithoutGuestInput
  likedReviews: ReviewUpdateManyWithoutUpVotesInput
  dislikedReviews: ReviewUpdateManyWithoutDownVotesInput
  preference: PreferenceUpdateOneWithoutCustomerInput
}

input CustomerUpdateWithoutReviewsDataInput {
  name: String
  email: String
  password: String
  phone: String
  address: AddressUpdateOneInput
  bookings: BookingUpdateManyWithoutGuestInput
  likedReviews: ReviewUpdateManyWithoutUpVotesInput
  dislikedReviews: ReviewUpdateManyWithoutDownVotesInput
  properties: PropertyUpdateManyWithoutOwnerInput
  preference: PreferenceUpdateOneWithoutCustomerInput
}

input CustomerUpdateWithWhereUniqueWithoutDislikedReviewsInput {
  where: CustomerWhereUniqueInput!
  data: CustomerUpdateWithoutDislikedReviewsDataInput!
}

input CustomerUpdateWithWhereUniqueWithoutLikedReviewsInput {
  where: CustomerWhereUniqueInput!
  data: CustomerUpdateWithoutLikedReviewsDataInput!
}

input CustomerUpsertWithoutBookingsInput {
  update: CustomerUpdateWithoutBookingsDataInput!
  create: CustomerCreateWithoutBookingsInput!
}

input CustomerUpsertWithoutPreferenceInput {
  update: CustomerUpdateWithoutPreferenceDataInput!
  create: CustomerCreateWithoutPreferenceInput!
}

input CustomerUpsertWithoutPropertiesInput {
  update: CustomerUpdateWithoutPropertiesDataInput!
  create: CustomerCreateWithoutPropertiesInput!
}

input CustomerUpsertWithoutReviewsInput {
  update: CustomerUpdateWithoutReviewsDataInput!
  create: CustomerCreateWithoutReviewsInput!
}

input CustomerUpsertWithWhereUniqueWithoutDislikedReviewsInput {
  where: CustomerWhereUniqueInput!
  update: CustomerUpdateWithoutDislikedReviewsDataInput!
  create: CustomerCreateWithoutDislikedReviewsInput!
}

input CustomerUpsertWithWhereUniqueWithoutLikedReviewsInput {
  where: CustomerWhereUniqueInput!
  update: CustomerUpdateWithoutLikedReviewsDataInput!
  create: CustomerCreateWithoutLikedReviewsInput!
}

input CustomerWhereInput {
  """Logical AND on all given filters."""
  AND: [CustomerWhereInput!]

  """Logical OR on all given filters."""
  OR: [CustomerWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CustomerWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  email: String

  """All values that are not equal to given value."""
  email_not: String

  """All values that are contained in given list."""
  email_in: [String!]

  """All values that are not contained in given list."""
  email_not_in: [String!]

  """All values less than the given value."""
  email_lt: String

  """All values less than or equal the given value."""
  email_lte: String

  """All values greater than the given value."""
  email_gt: String

  """All values greater than or equal the given value."""
  email_gte: String

  """All values containing the given string."""
  email_contains: String

  """All values not containing the given string."""
  email_not_contains: String

  """All values starting with the given string."""
  email_starts_with: String

  """All values not starting with the given string."""
  email_not_starts_with: String

  """All values ending with the given string."""
  email_ends_with: String

  """All values not ending with the given string."""
  email_not_ends_with: String
  password: String

  """All values that are not equal to given value."""
  password_not: String

  """All values that are contained in given list."""
  password_in: [String!]

  """All values that are not contained in given list."""
  password_not_in: [String!]

  """All values less than the given value."""
  password_lt: String

  """All values less than or equal the given value."""
  password_lte: String

  """All values greater than the given value."""
  password_gt: String

  """All values greater than or equal the given value."""
  password_gte: String

  """All values containing the given string."""
  password_contains: String

  """All values not containing the given string."""
  password_not_contains: String

  """All values starting with the given string."""
  password_starts_with: String

  """All values not starting with the given string."""
  password_not_starts_with: String

  """All values ending with the given string."""
  password_ends_with: String

  """All values not ending with the given string."""
  password_not_ends_with: String
  phone: String

  """All values that are not equal to given value."""
  phone_not: String

  """All values that are contained in given list."""
  phone_in: [String!]

  """All values that are not contained in given list."""
  phone_not_in: [String!]

  """All values less than the given value."""
  phone_lt: String

  """All values less than or equal the given value."""
  phone_lte: String

  """All values greater than the given value."""
  phone_gt: String

  """All values greater than or equal the given value."""
  phone_gte: String

  """All values containing the given string."""
  phone_contains: String

  """All values not containing the given string."""
  phone_not_contains: String

  """All values starting with the given string."""
  phone_starts_with: String

  """All values not starting with the given string."""
  phone_not_starts_with: String

  """All values ending with the given string."""
  phone_ends_with: String

  """All values not ending with the given string."""
  phone_not_ends_with: String
  address: AddressWhereInput
  reviews_every: ReviewWhereInput
  reviews_some: ReviewWhereInput
  reviews_none: ReviewWhereInput
  bookings_every: BookingWhereInput
  bookings_some: BookingWhereInput
  bookings_none: BookingWhereInput
  likedReviews_every: ReviewWhereInput
  likedReviews_some: ReviewWhereInput
  likedReviews_none: ReviewWhereInput
  dislikedReviews_every: ReviewWhereInput
  dislikedReviews_some: ReviewWhereInput
  dislikedReviews_none: ReviewWhereInput
  properties_every: PropertyWhereInput
  properties_some: PropertyWhereInput
  properties_none: PropertyWhereInput
  preference: PreferenceWhereInput
}

input CustomerWhereUniqueInput {
  id: ID
  email: String
}

scalar DateTime

type Facility implements Node {
  id: ID!
  name: String!
  type(where: FacilityTypeWhereInput): FacilityType!
  properties(where: PropertyFacilityWhereInput, orderBy: PropertyFacilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PropertyFacility!]
  rooms(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Room!]
}

"""A connection to a list of items."""
type FacilityConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [FacilityEdge]!
  aggregate: AggregateFacility!
}

input FacilityCreateInput {
  name: String!
  type: FacilityTypeCreateOneWithoutFacilitiesInput!
  properties: PropertyFacilityCreateManyWithoutFacilityInput
  rooms: RoomCreateManyWithoutFacilitiesInput
}

input FacilityCreateManyWithoutRoomsInput {
  create: [FacilityCreateWithoutRoomsInput!]
  connect: [FacilityWhereUniqueInput!]
}

input FacilityCreateManyWithoutTypeInput {
  create: [FacilityCreateWithoutTypeInput!]
  connect: [FacilityWhereUniqueInput!]
}

input FacilityCreateOneWithoutPropertiesInput {
  create: FacilityCreateWithoutPropertiesInput
  connect: FacilityWhereUniqueInput
}

input FacilityCreateWithoutPropertiesInput {
  name: String!
  type: FacilityTypeCreateOneWithoutFacilitiesInput!
  rooms: RoomCreateManyWithoutFacilitiesInput
}

input FacilityCreateWithoutRoomsInput {
  name: String!
  type: FacilityTypeCreateOneWithoutFacilitiesInput!
  properties: PropertyFacilityCreateManyWithoutFacilityInput
}

input FacilityCreateWithoutTypeInput {
  name: String!
  properties: PropertyFacilityCreateManyWithoutFacilityInput
  rooms: RoomCreateManyWithoutFacilitiesInput
}

"""An edge in a connection."""
type FacilityEdge {
  """The item at the end of the edge."""
  node: Facility!

  """A cursor for use in pagination."""
  cursor: String!
}

enum FacilityOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type FacilityPreviousValues {
  id: ID!
  name: String!
}

type FacilitySubscriptionPayload {
  mutation: MutationType!
  node: Facility
  updatedFields: [String!]
  previousValues: FacilityPreviousValues
}

input FacilitySubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [FacilitySubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [FacilitySubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [FacilitySubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: FacilityWhereInput
}

type FacilityType implements Node {
  id: ID!
  name: String!
  facilities(where: FacilityWhereInput, orderBy: FacilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Facility!]
}

"""A connection to a list of items."""
type FacilityTypeConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [FacilityTypeEdge]!
  aggregate: AggregateFacilityType!
}

input FacilityTypeCreateInput {
  name: String!
  facilities: FacilityCreateManyWithoutTypeInput
}

input FacilityTypeCreateOneWithoutFacilitiesInput {
  create: FacilityTypeCreateWithoutFacilitiesInput
  connect: FacilityTypeWhereUniqueInput
}

input FacilityTypeCreateWithoutFacilitiesInput {
  name: String!
}

"""An edge in a connection."""
type FacilityTypeEdge {
  """The item at the end of the edge."""
  node: FacilityType!

  """A cursor for use in pagination."""
  cursor: String!
}

enum FacilityTypeOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type FacilityTypePreviousValues {
  id: ID!
  name: String!
}

type FacilityTypeSubscriptionPayload {
  mutation: MutationType!
  node: FacilityType
  updatedFields: [String!]
  previousValues: FacilityTypePreviousValues
}

input FacilityTypeSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [FacilityTypeSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [FacilityTypeSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [FacilityTypeSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: FacilityTypeWhereInput
}

input FacilityTypeUpdateInput {
  name: String
  facilities: FacilityUpdateManyWithoutTypeInput
}

input FacilityTypeUpdateOneWithoutFacilitiesInput {
  create: FacilityTypeCreateWithoutFacilitiesInput
  connect: FacilityTypeWhereUniqueInput
  delete: Boolean
  update: FacilityTypeUpdateWithoutFacilitiesDataInput
  upsert: FacilityTypeUpsertWithoutFacilitiesInput
}

input FacilityTypeUpdateWithoutFacilitiesDataInput {
  name: String
}

input FacilityTypeUpsertWithoutFacilitiesInput {
  update: FacilityTypeUpdateWithoutFacilitiesDataInput!
  create: FacilityTypeCreateWithoutFacilitiesInput!
}

input FacilityTypeWhereInput {
  """Logical AND on all given filters."""
  AND: [FacilityTypeWhereInput!]

  """Logical OR on all given filters."""
  OR: [FacilityTypeWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [FacilityTypeWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  facilities_every: FacilityWhereInput
  facilities_some: FacilityWhereInput
  facilities_none: FacilityWhereInput
}

input FacilityTypeWhereUniqueInput {
  id: ID
  name: String
}

input FacilityUpdateInput {
  name: String
  type: FacilityTypeUpdateOneWithoutFacilitiesInput
  properties: PropertyFacilityUpdateManyWithoutFacilityInput
  rooms: RoomUpdateManyWithoutFacilitiesInput
}

input FacilityUpdateManyWithoutRoomsInput {
  create: [FacilityCreateWithoutRoomsInput!]
  connect: [FacilityWhereUniqueInput!]
  disconnect: [FacilityWhereUniqueInput!]
  delete: [FacilityWhereUniqueInput!]
  update: [FacilityUpdateWithWhereUniqueWithoutRoomsInput!]
  upsert: [FacilityUpsertWithWhereUniqueWithoutRoomsInput!]
}

input FacilityUpdateManyWithoutTypeInput {
  create: [FacilityCreateWithoutTypeInput!]
  connect: [FacilityWhereUniqueInput!]
  disconnect: [FacilityWhereUniqueInput!]
  delete: [FacilityWhereUniqueInput!]
  update: [FacilityUpdateWithWhereUniqueWithoutTypeInput!]
  upsert: [FacilityUpsertWithWhereUniqueWithoutTypeInput!]
}

input FacilityUpdateOneWithoutPropertiesInput {
  create: FacilityCreateWithoutPropertiesInput
  connect: FacilityWhereUniqueInput
  delete: Boolean
  update: FacilityUpdateWithoutPropertiesDataInput
  upsert: FacilityUpsertWithoutPropertiesInput
}

input FacilityUpdateWithoutPropertiesDataInput {
  name: String
  type: FacilityTypeUpdateOneWithoutFacilitiesInput
  rooms: RoomUpdateManyWithoutFacilitiesInput
}

input FacilityUpdateWithoutRoomsDataInput {
  name: String
  type: FacilityTypeUpdateOneWithoutFacilitiesInput
  properties: PropertyFacilityUpdateManyWithoutFacilityInput
}

input FacilityUpdateWithoutTypeDataInput {
  name: String
  properties: PropertyFacilityUpdateManyWithoutFacilityInput
  rooms: RoomUpdateManyWithoutFacilitiesInput
}

input FacilityUpdateWithWhereUniqueWithoutRoomsInput {
  where: FacilityWhereUniqueInput!
  data: FacilityUpdateWithoutRoomsDataInput!
}

input FacilityUpdateWithWhereUniqueWithoutTypeInput {
  where: FacilityWhereUniqueInput!
  data: FacilityUpdateWithoutTypeDataInput!
}

input FacilityUpsertWithoutPropertiesInput {
  update: FacilityUpdateWithoutPropertiesDataInput!
  create: FacilityCreateWithoutPropertiesInput!
}

input FacilityUpsertWithWhereUniqueWithoutRoomsInput {
  where: FacilityWhereUniqueInput!
  update: FacilityUpdateWithoutRoomsDataInput!
  create: FacilityCreateWithoutRoomsInput!
}

input FacilityUpsertWithWhereUniqueWithoutTypeInput {
  where: FacilityWhereUniqueInput!
  update: FacilityUpdateWithoutTypeDataInput!
  create: FacilityCreateWithoutTypeInput!
}

input FacilityWhereInput {
  """Logical AND on all given filters."""
  AND: [FacilityWhereInput!]

  """Logical OR on all given filters."""
  OR: [FacilityWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [FacilityWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  type: FacilityTypeWhereInput
  properties_every: PropertyFacilityWhereInput
  properties_some: PropertyFacilityWhereInput
  properties_none: PropertyFacilityWhereInput
  rooms_every: RoomWhereInput
  rooms_some: RoomWhereInput
  rooms_none: RoomWhereInput
}

input FacilityWhereUniqueInput {
  id: ID
  name: String
}

type Language implements Node {
  id: ID!
  code: String!
  name: String!
  countries(where: CountryWhereInput, orderBy: CountryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Country!]
}

"""A connection to a list of items."""
type LanguageConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [LanguageEdge]!
  aggregate: AggregateLanguage!
}

input LanguageCreateInput {
  code: String!
  name: String!
  countries: CountryCreateManyWithoutLanguagesInput
}

input LanguageCreateManyWithoutCountriesInput {
  create: [LanguageCreateWithoutCountriesInput!]
  connect: [LanguageWhereUniqueInput!]
}

input LanguageCreateWithoutCountriesInput {
  code: String!
  name: String!
}

"""An edge in a connection."""
type LanguageEdge {
  """The item at the end of the edge."""
  node: Language!

  """A cursor for use in pagination."""
  cursor: String!
}

enum LanguageOrderByInput {
  id_ASC
  id_DESC
  code_ASC
  code_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type LanguagePreviousValues {
  id: ID!
  code: String!
  name: String!
}

type LanguageSubscriptionPayload {
  mutation: MutationType!
  node: Language
  updatedFields: [String!]
  previousValues: LanguagePreviousValues
}

input LanguageSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [LanguageSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [LanguageSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [LanguageSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: LanguageWhereInput
}

input LanguageUpdateInput {
  code: String
  name: String
  countries: CountryUpdateManyWithoutLanguagesInput
}

input LanguageUpdateManyWithoutCountriesInput {
  create: [LanguageCreateWithoutCountriesInput!]
  connect: [LanguageWhereUniqueInput!]
  disconnect: [LanguageWhereUniqueInput!]
  delete: [LanguageWhereUniqueInput!]
  update: [LanguageUpdateWithWhereUniqueWithoutCountriesInput!]
  upsert: [LanguageUpsertWithWhereUniqueWithoutCountriesInput!]
}

input LanguageUpdateWithoutCountriesDataInput {
  code: String
  name: String
}

input LanguageUpdateWithWhereUniqueWithoutCountriesInput {
  where: LanguageWhereUniqueInput!
  data: LanguageUpdateWithoutCountriesDataInput!
}

input LanguageUpsertWithWhereUniqueWithoutCountriesInput {
  where: LanguageWhereUniqueInput!
  update: LanguageUpdateWithoutCountriesDataInput!
  create: LanguageCreateWithoutCountriesInput!
}

input LanguageWhereInput {
  """Logical AND on all given filters."""
  AND: [LanguageWhereInput!]

  """Logical OR on all given filters."""
  OR: [LanguageWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [LanguageWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  code: String

  """All values that are not equal to given value."""
  code_not: String

  """All values that are contained in given list."""
  code_in: [String!]

  """All values that are not contained in given list."""
  code_not_in: [String!]

  """All values less than the given value."""
  code_lt: String

  """All values less than or equal the given value."""
  code_lte: String

  """All values greater than the given value."""
  code_gt: String

  """All values greater than or equal the given value."""
  code_gte: String

  """All values containing the given string."""
  code_contains: String

  """All values not containing the given string."""
  code_not_contains: String

  """All values starting with the given string."""
  code_starts_with: String

  """All values not starting with the given string."""
  code_not_starts_with: String

  """All values ending with the given string."""
  code_ends_with: String

  """All values not ending with the given string."""
  code_not_ends_with: String
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  countries_every: CountryWhereInput
  countries_some: CountryWhereInput
  countries_none: CountryWhereInput
}

input LanguageWhereUniqueInput {
  id: ID
  code: String
  name: String
}

"""
The `Long` scalar type represents non-fractional signed whole numeric values.
Long can represent values between -(2^63) and 2^63 - 1.
"""
scalar Long

type Mutation {
  createCustomer(data: CustomerCreateInput!): Customer!
  createProperty(data: PropertyCreateInput!): Property!
  createCategory(data: CategoryCreateInput!): Category!
  createRoom(data: RoomCreateInput!): Room!
  createBed(data: BedCreateInput!): Bed!
  createBedType(data: BedTypeCreateInput!): BedType!
  createFacility(data: FacilityCreateInput!): Facility!
  createPropertyFacility(data: PropertyFacilityCreateInput!): PropertyFacility!
  createFacilityType(data: FacilityTypeCreateInput!): FacilityType!
  createPolicy(data: PolicyCreateInput!): Policy!
  createReview(data: ReviewCreateInput!): Review!
  createOrder(data: OrderCreateInput!): Order!
  createTimezone(data: TimezoneCreateInput!): Timezone!
  createLanguage(data: LanguageCreateInput!): Language!
  createPreference(data: PreferenceCreateInput!): Preference!
  createTax(data: TaxCreateInput!): Tax!
  createPromo(data: PromoCreateInput!): Promo!
  createBooking(data: BookingCreateInput!): Booking!
  createCountry(data: CountryCreateInput!): Country!
  createAddress(data: AddressCreateInput!): Address!
  createPriceType(data: PriceTypeCreateInput!): PriceType!
  createPrice(data: PriceCreateInput!): Price!
  createCurrency(data: CurrencyCreateInput!): Currency!
  updateCustomer(data: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer
  updateProperty(data: PropertyUpdateInput!, where: PropertyWhereUniqueInput!): Property
  updateCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category
  updateRoom(data: RoomUpdateInput!, where: RoomWhereUniqueInput!): Room
  updateBed(data: BedUpdateInput!, where: BedWhereUniqueInput!): Bed
  updateBedType(data: BedTypeUpdateInput!, where: BedTypeWhereUniqueInput!): BedType
  updateFacility(data: FacilityUpdateInput!, where: FacilityWhereUniqueInput!): Facility
  updatePropertyFacility(data: PropertyFacilityUpdateInput!, where: PropertyFacilityWhereUniqueInput!): PropertyFacility
  updateFacilityType(data: FacilityTypeUpdateInput!, where: FacilityTypeWhereUniqueInput!): FacilityType
  updatePolicy(data: PolicyUpdateInput!, where: PolicyWhereUniqueInput!): Policy
  updateReview(data: ReviewUpdateInput!, where: ReviewWhereUniqueInput!): Review
  updateOrder(data: OrderUpdateInput!, where: OrderWhereUniqueInput!): Order
  updateTimezone(data: TimezoneUpdateInput!, where: TimezoneWhereUniqueInput!): Timezone
  updateLanguage(data: LanguageUpdateInput!, where: LanguageWhereUniqueInput!): Language
  updatePreference(data: PreferenceUpdateInput!, where: PreferenceWhereUniqueInput!): Preference
  updateTax(data: TaxUpdateInput!, where: TaxWhereUniqueInput!): Tax
  updatePromo(data: PromoUpdateInput!, where: PromoWhereUniqueInput!): Promo
  updateBooking(data: BookingUpdateInput!, where: BookingWhereUniqueInput!): Booking
  updateCountry(data: CountryUpdateInput!, where: CountryWhereUniqueInput!): Country
  updateAddress(data: AddressUpdateInput!, where: AddressWhereUniqueInput!): Address
  updatePriceType(data: PriceTypeUpdateInput!, where: PriceTypeWhereUniqueInput!): PriceType
  updatePrice(data: PriceUpdateInput!, where: PriceWhereUniqueInput!): Price
  updateCurrency(data: CurrencyUpdateInput!, where: CurrencyWhereUniqueInput!): Currency
  deleteCustomer(where: CustomerWhereUniqueInput!): Customer
  deleteProperty(where: PropertyWhereUniqueInput!): Property
  deleteCategory(where: CategoryWhereUniqueInput!): Category
  deleteRoom(where: RoomWhereUniqueInput!): Room
  deleteBed(where: BedWhereUniqueInput!): Bed
  deleteBedType(where: BedTypeWhereUniqueInput!): BedType
  deleteFacility(where: FacilityWhereUniqueInput!): Facility
  deletePropertyFacility(where: PropertyFacilityWhereUniqueInput!): PropertyFacility
  deleteFacilityType(where: FacilityTypeWhereUniqueInput!): FacilityType
  deletePolicy(where: PolicyWhereUniqueInput!): Policy
  deleteReview(where: ReviewWhereUniqueInput!): Review
  deleteOrder(where: OrderWhereUniqueInput!): Order
  deleteTimezone(where: TimezoneWhereUniqueInput!): Timezone
  deleteLanguage(where: LanguageWhereUniqueInput!): Language
  deletePreference(where: PreferenceWhereUniqueInput!): Preference
  deleteTax(where: TaxWhereUniqueInput!): Tax
  deletePromo(where: PromoWhereUniqueInput!): Promo
  deleteBooking(where: BookingWhereUniqueInput!): Booking
  deleteCountry(where: CountryWhereUniqueInput!): Country
  deleteAddress(where: AddressWhereUniqueInput!): Address
  deletePriceType(where: PriceTypeWhereUniqueInput!): PriceType
  deletePrice(where: PriceWhereUniqueInput!): Price
  deleteCurrency(where: CurrencyWhereUniqueInput!): Currency
  upsertCustomer(where: CustomerWhereUniqueInput!, create: CustomerCreateInput!, update: CustomerUpdateInput!): Customer!
  upsertProperty(where: PropertyWhereUniqueInput!, create: PropertyCreateInput!, update: PropertyUpdateInput!): Property!
  upsertCategory(where: CategoryWhereUniqueInput!, create: CategoryCreateInput!, update: CategoryUpdateInput!): Category!
  upsertRoom(where: RoomWhereUniqueInput!, create: RoomCreateInput!, update: RoomUpdateInput!): Room!
  upsertBed(where: BedWhereUniqueInput!, create: BedCreateInput!, update: BedUpdateInput!): Bed!
  upsertBedType(where: BedTypeWhereUniqueInput!, create: BedTypeCreateInput!, update: BedTypeUpdateInput!): BedType!
  upsertFacility(where: FacilityWhereUniqueInput!, create: FacilityCreateInput!, update: FacilityUpdateInput!): Facility!
  upsertPropertyFacility(where: PropertyFacilityWhereUniqueInput!, create: PropertyFacilityCreateInput!, update: PropertyFacilityUpdateInput!): PropertyFacility!
  upsertFacilityType(where: FacilityTypeWhereUniqueInput!, create: FacilityTypeCreateInput!, update: FacilityTypeUpdateInput!): FacilityType!
  upsertPolicy(where: PolicyWhereUniqueInput!, create: PolicyCreateInput!, update: PolicyUpdateInput!): Policy!
  upsertReview(where: ReviewWhereUniqueInput!, create: ReviewCreateInput!, update: ReviewUpdateInput!): Review!
  upsertOrder(where: OrderWhereUniqueInput!, create: OrderCreateInput!, update: OrderUpdateInput!): Order!
  upsertTimezone(where: TimezoneWhereUniqueInput!, create: TimezoneCreateInput!, update: TimezoneUpdateInput!): Timezone!
  upsertLanguage(where: LanguageWhereUniqueInput!, create: LanguageCreateInput!, update: LanguageUpdateInput!): Language!
  upsertPreference(where: PreferenceWhereUniqueInput!, create: PreferenceCreateInput!, update: PreferenceUpdateInput!): Preference!
  upsertTax(where: TaxWhereUniqueInput!, create: TaxCreateInput!, update: TaxUpdateInput!): Tax!
  upsertPromo(where: PromoWhereUniqueInput!, create: PromoCreateInput!, update: PromoUpdateInput!): Promo!
  upsertBooking(where: BookingWhereUniqueInput!, create: BookingCreateInput!, update: BookingUpdateInput!): Booking!
  upsertCountry(where: CountryWhereUniqueInput!, create: CountryCreateInput!, update: CountryUpdateInput!): Country!
  upsertAddress(where: AddressWhereUniqueInput!, create: AddressCreateInput!, update: AddressUpdateInput!): Address!
  upsertPriceType(where: PriceTypeWhereUniqueInput!, create: PriceTypeCreateInput!, update: PriceTypeUpdateInput!): PriceType!
  upsertPrice(where: PriceWhereUniqueInput!, create: PriceCreateInput!, update: PriceUpdateInput!): Price!
  upsertCurrency(where: CurrencyWhereUniqueInput!, create: CurrencyCreateInput!, update: CurrencyUpdateInput!): Currency!
  updateManyCustomers(data: CustomerUpdateInput!, where: CustomerWhereInput): BatchPayload!
  updateManyProperties(data: PropertyUpdateInput!, where: PropertyWhereInput): BatchPayload!
  updateManyCategories(data: CategoryUpdateInput!, where: CategoryWhereInput): BatchPayload!
  updateManyRooms(data: RoomUpdateInput!, where: RoomWhereInput): BatchPayload!
  updateManyBeds(data: BedUpdateInput!, where: BedWhereInput): BatchPayload!
  updateManyBedTypes(data: BedTypeUpdateInput!, where: BedTypeWhereInput): BatchPayload!
  updateManyFacilities(data: FacilityUpdateInput!, where: FacilityWhereInput): BatchPayload!
  updateManyPropertyFacilities(data: PropertyFacilityUpdateInput!, where: PropertyFacilityWhereInput): BatchPayload!
  updateManyFacilityTypes(data: FacilityTypeUpdateInput!, where: FacilityTypeWhereInput): BatchPayload!
  updateManyPolicies(data: PolicyUpdateInput!, where: PolicyWhereInput): BatchPayload!
  updateManyReviews(data: ReviewUpdateInput!, where: ReviewWhereInput): BatchPayload!
  updateManyOrders(data: OrderUpdateInput!, where: OrderWhereInput): BatchPayload!
  updateManyTimezones(data: TimezoneUpdateInput!, where: TimezoneWhereInput): BatchPayload!
  updateManyLanguages(data: LanguageUpdateInput!, where: LanguageWhereInput): BatchPayload!
  updateManyPreferences(data: PreferenceUpdateInput!, where: PreferenceWhereInput): BatchPayload!
  updateManyTaxes(data: TaxUpdateInput!, where: TaxWhereInput): BatchPayload!
  updateManyPromoes(data: PromoUpdateInput!, where: PromoWhereInput): BatchPayload!
  updateManyBookings(data: BookingUpdateInput!, where: BookingWhereInput): BatchPayload!
  updateManyCountries(data: CountryUpdateInput!, where: CountryWhereInput): BatchPayload!
  updateManyAddresses(data: AddressUpdateInput!, where: AddressWhereInput): BatchPayload!
  updateManyPriceTypes(data: PriceTypeUpdateInput!, where: PriceTypeWhereInput): BatchPayload!
  updateManyPrices(data: PriceUpdateInput!, where: PriceWhereInput): BatchPayload!
  updateManyCurrencies(data: CurrencyUpdateInput!, where: CurrencyWhereInput): BatchPayload!
  deleteManyCustomers(where: CustomerWhereInput): BatchPayload!
  deleteManyProperties(where: PropertyWhereInput): BatchPayload!
  deleteManyCategories(where: CategoryWhereInput): BatchPayload!
  deleteManyRooms(where: RoomWhereInput): BatchPayload!
  deleteManyBeds(where: BedWhereInput): BatchPayload!
  deleteManyBedTypes(where: BedTypeWhereInput): BatchPayload!
  deleteManyFacilities(where: FacilityWhereInput): BatchPayload!
  deleteManyPropertyFacilities(where: PropertyFacilityWhereInput): BatchPayload!
  deleteManyFacilityTypes(where: FacilityTypeWhereInput): BatchPayload!
  deleteManyPolicies(where: PolicyWhereInput): BatchPayload!
  deleteManyReviews(where: ReviewWhereInput): BatchPayload!
  deleteManyOrders(where: OrderWhereInput): BatchPayload!
  deleteManyTimezones(where: TimezoneWhereInput): BatchPayload!
  deleteManyLanguages(where: LanguageWhereInput): BatchPayload!
  deleteManyPreferences(where: PreferenceWhereInput): BatchPayload!
  deleteManyTaxes(where: TaxWhereInput): BatchPayload!
  deleteManyPromoes(where: PromoWhereInput): BatchPayload!
  deleteManyBookings(where: BookingWhereInput): BatchPayload!
  deleteManyCountries(where: CountryWhereInput): BatchPayload!
  deleteManyAddresses(where: AddressWhereInput): BatchPayload!
  deleteManyPriceTypes(where: PriceTypeWhereInput): BatchPayload!
  deleteManyPrices(where: PriceWhereInput): BatchPayload!
  deleteManyCurrencies(where: CurrencyWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

"""An object with an ID"""
interface Node {
  """The id of the object."""
  id: ID!
}

type Order implements Node {
  id: ID!
  booking(where: BookingWhereInput): Booking!
  amount: Float!
  taxes(where: TaxWhereInput, orderBy: TaxOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tax!]
  promos(where: PromoWhereInput, orderBy: PromoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Promo!]
  payable: Float!
  status: Status!
}

"""A connection to a list of items."""
type OrderConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [OrderEdge]!
  aggregate: AggregateOrder!
}

input OrderCreateInput {
  amount: Float!
  payable: Float!
  status: Status!
  booking: BookingCreateOneInput!
  taxes: TaxCreateManyInput
  promos: PromoCreateManyInput
}

"""An edge in a connection."""
type OrderEdge {
  """The item at the end of the edge."""
  node: Order!

  """A cursor for use in pagination."""
  cursor: String!
}

enum OrderOrderByInput {
  id_ASC
  id_DESC
  amount_ASC
  amount_DESC
  payable_ASC
  payable_DESC
  status_ASC
  status_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type OrderPreviousValues {
  id: ID!
  amount: Float!
  payable: Float!
  status: Status!
}

type OrderSubscriptionPayload {
  mutation: MutationType!
  node: Order
  updatedFields: [String!]
  previousValues: OrderPreviousValues
}

input OrderSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [OrderSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [OrderSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [OrderSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: OrderWhereInput
}

input OrderUpdateInput {
  amount: Float
  payable: Float
  status: Status
  booking: BookingUpdateOneInput
  taxes: TaxUpdateManyInput
  promos: PromoUpdateManyInput
}

input OrderWhereInput {
  """Logical AND on all given filters."""
  AND: [OrderWhereInput!]

  """Logical OR on all given filters."""
  OR: [OrderWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [OrderWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  amount: Float

  """All values that are not equal to given value."""
  amount_not: Float

  """All values that are contained in given list."""
  amount_in: [Float!]

  """All values that are not contained in given list."""
  amount_not_in: [Float!]

  """All values less than the given value."""
  amount_lt: Float

  """All values less than or equal the given value."""
  amount_lte: Float

  """All values greater than the given value."""
  amount_gt: Float

  """All values greater than or equal the given value."""
  amount_gte: Float
  payable: Float

  """All values that are not equal to given value."""
  payable_not: Float

  """All values that are contained in given list."""
  payable_in: [Float!]

  """All values that are not contained in given list."""
  payable_not_in: [Float!]

  """All values less than the given value."""
  payable_lt: Float

  """All values less than or equal the given value."""
  payable_lte: Float

  """All values greater than the given value."""
  payable_gt: Float

  """All values greater than or equal the given value."""
  payable_gte: Float
  status: Status

  """All values that are not equal to given value."""
  status_not: Status

  """All values that are contained in given list."""
  status_in: [Status!]

  """All values that are not contained in given list."""
  status_not_in: [Status!]
  booking: BookingWhereInput
  taxes_every: TaxWhereInput
  taxes_some: TaxWhereInput
  taxes_none: TaxWhereInput
  promos_every: PromoWhereInput
  promos_some: PromoWhereInput
  promos_none: PromoWhereInput
}

input OrderWhereUniqueInput {
  id: ID
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

type Policy implements Node {
  id: ID!
  policy: String!
  properties(where: PropertyWhereInput, orderBy: PropertyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Property!]
}

"""A connection to a list of items."""
type PolicyConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [PolicyEdge]!
  aggregate: AggregatePolicy!
}

input PolicyCreateInput {
  policy: String!
  properties: PropertyCreateManyWithoutPoliciesInput
}

input PolicyCreateManyWithoutPropertiesInput {
  create: [PolicyCreateWithoutPropertiesInput!]
  connect: [PolicyWhereUniqueInput!]
}

input PolicyCreateWithoutPropertiesInput {
  policy: String!
}

"""An edge in a connection."""
type PolicyEdge {
  """The item at the end of the edge."""
  node: Policy!

  """A cursor for use in pagination."""
  cursor: String!
}

enum PolicyOrderByInput {
  id_ASC
  id_DESC
  policy_ASC
  policy_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type PolicyPreviousValues {
  id: ID!
  policy: String!
}

type PolicySubscriptionPayload {
  mutation: MutationType!
  node: Policy
  updatedFields: [String!]
  previousValues: PolicyPreviousValues
}

input PolicySubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [PolicySubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [PolicySubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [PolicySubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: PolicyWhereInput
}

input PolicyUpdateInput {
  policy: String
  properties: PropertyUpdateManyWithoutPoliciesInput
}

input PolicyUpdateManyWithoutPropertiesInput {
  create: [PolicyCreateWithoutPropertiesInput!]
  connect: [PolicyWhereUniqueInput!]
  disconnect: [PolicyWhereUniqueInput!]
  delete: [PolicyWhereUniqueInput!]
  update: [PolicyUpdateWithWhereUniqueWithoutPropertiesInput!]
  upsert: [PolicyUpsertWithWhereUniqueWithoutPropertiesInput!]
}

input PolicyUpdateWithoutPropertiesDataInput {
  policy: String
}

input PolicyUpdateWithWhereUniqueWithoutPropertiesInput {
  where: PolicyWhereUniqueInput!
  data: PolicyUpdateWithoutPropertiesDataInput!
}

input PolicyUpsertWithWhereUniqueWithoutPropertiesInput {
  where: PolicyWhereUniqueInput!
  update: PolicyUpdateWithoutPropertiesDataInput!
  create: PolicyCreateWithoutPropertiesInput!
}

input PolicyWhereInput {
  """Logical AND on all given filters."""
  AND: [PolicyWhereInput!]

  """Logical OR on all given filters."""
  OR: [PolicyWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [PolicyWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  policy: String

  """All values that are not equal to given value."""
  policy_not: String

  """All values that are contained in given list."""
  policy_in: [String!]

  """All values that are not contained in given list."""
  policy_not_in: [String!]

  """All values less than the given value."""
  policy_lt: String

  """All values less than or equal the given value."""
  policy_lte: String

  """All values greater than the given value."""
  policy_gt: String

  """All values greater than or equal the given value."""
  policy_gte: String

  """All values containing the given string."""
  policy_contains: String

  """All values not containing the given string."""
  policy_not_contains: String

  """All values starting with the given string."""
  policy_starts_with: String

  """All values not starting with the given string."""
  policy_not_starts_with: String

  """All values ending with the given string."""
  policy_ends_with: String

  """All values not ending with the given string."""
  policy_not_ends_with: String
  properties_every: PropertyWhereInput
  properties_some: PropertyWhereInput
  properties_none: PropertyWhereInput
}

input PolicyWhereUniqueInput {
  id: ID
  policy: String
}

type Preference implements Node {
  id: ID!
  country(where: CountryWhereInput): Country
  customer(where: CustomerWhereInput): Customer!
}

"""A connection to a list of items."""
type PreferenceConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [PreferenceEdge]!
  aggregate: AggregatePreference!
}

input PreferenceCreateInput {
  country: CountryCreateOneInput
  customer: CustomerCreateOneWithoutPreferenceInput!
}

input PreferenceCreateOneWithoutCustomerInput {
  create: PreferenceCreateWithoutCustomerInput
  connect: PreferenceWhereUniqueInput
}

input PreferenceCreateWithoutCustomerInput {
  country: CountryCreateOneInput
}

"""An edge in a connection."""
type PreferenceEdge {
  """The item at the end of the edge."""
  node: Preference!

  """A cursor for use in pagination."""
  cursor: String!
}

enum PreferenceOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type PreferencePreviousValues {
  id: ID!
}

type PreferenceSubscriptionPayload {
  mutation: MutationType!
  node: Preference
  updatedFields: [String!]
  previousValues: PreferencePreviousValues
}

input PreferenceSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [PreferenceSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [PreferenceSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [PreferenceSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: PreferenceWhereInput
}

input PreferenceUpdateInput {
  country: CountryUpdateOneInput
  customer: CustomerUpdateOneWithoutPreferenceInput
}

input PreferenceUpdateOneWithoutCustomerInput {
  create: PreferenceCreateWithoutCustomerInput
  connect: PreferenceWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: PreferenceUpdateWithoutCustomerDataInput
  upsert: PreferenceUpsertWithoutCustomerInput
}

input PreferenceUpdateWithoutCustomerDataInput {
  country: CountryUpdateOneInput
}

input PreferenceUpsertWithoutCustomerInput {
  update: PreferenceUpdateWithoutCustomerDataInput!
  create: PreferenceCreateWithoutCustomerInput!
}

input PreferenceWhereInput {
  """Logical AND on all given filters."""
  AND: [PreferenceWhereInput!]

  """Logical OR on all given filters."""
  OR: [PreferenceWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [PreferenceWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  country: CountryWhereInput
  customer: CustomerWhereInput
}

input PreferenceWhereUniqueInput {
  id: ID
}

type Price implements Node {
  id: ID!
  amount: Float!
  currency(where: CurrencyWhereInput): Currency!
  type(where: PriceTypeWhereInput): PriceType!
}

"""A connection to a list of items."""
type PriceConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [PriceEdge]!
  aggregate: AggregatePrice!
}

input PriceCreateInput {
  amount: Float!
  currency: CurrencyCreateOneInput!
  type: PriceTypeCreateOneInput!
}

input PriceCreateManyInput {
  create: [PriceCreateInput!]
  connect: [PriceWhereUniqueInput!]
}

"""An edge in a connection."""
type PriceEdge {
  """The item at the end of the edge."""
  node: Price!

  """A cursor for use in pagination."""
  cursor: String!
}

enum PriceOrderByInput {
  id_ASC
  id_DESC
  amount_ASC
  amount_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type PricePreviousValues {
  id: ID!
  amount: Float!
}

type PriceSubscriptionPayload {
  mutation: MutationType!
  node: Price
  updatedFields: [String!]
  previousValues: PricePreviousValues
}

input PriceSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [PriceSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [PriceSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [PriceSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: PriceWhereInput
}

type PriceType implements Node {
  id: ID!
  name: String!
}

"""A connection to a list of items."""
type PriceTypeConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [PriceTypeEdge]!
  aggregate: AggregatePriceType!
}

input PriceTypeCreateInput {
  name: String!
}

input PriceTypeCreateOneInput {
  create: PriceTypeCreateInput
  connect: PriceTypeWhereUniqueInput
}

"""An edge in a connection."""
type PriceTypeEdge {
  """The item at the end of the edge."""
  node: PriceType!

  """A cursor for use in pagination."""
  cursor: String!
}

enum PriceTypeOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type PriceTypePreviousValues {
  id: ID!
  name: String!
}

type PriceTypeSubscriptionPayload {
  mutation: MutationType!
  node: PriceType
  updatedFields: [String!]
  previousValues: PriceTypePreviousValues
}

input PriceTypeSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [PriceTypeSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [PriceTypeSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [PriceTypeSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: PriceTypeWhereInput
}

input PriceTypeUpdateDataInput {
  name: String
}

input PriceTypeUpdateInput {
  name: String
}

input PriceTypeUpdateOneInput {
  create: PriceTypeCreateInput
  connect: PriceTypeWhereUniqueInput
  delete: Boolean
  update: PriceTypeUpdateDataInput
  upsert: PriceTypeUpsertNestedInput
}

input PriceTypeUpsertNestedInput {
  update: PriceTypeUpdateDataInput!
  create: PriceTypeCreateInput!
}

input PriceTypeWhereInput {
  """Logical AND on all given filters."""
  AND: [PriceTypeWhereInput!]

  """Logical OR on all given filters."""
  OR: [PriceTypeWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [PriceTypeWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  _MagicalBackRelation_PriceToPriceType_every: PriceWhereInput
  _MagicalBackRelation_PriceToPriceType_some: PriceWhereInput
  _MagicalBackRelation_PriceToPriceType_none: PriceWhereInput
}

input PriceTypeWhereUniqueInput {
  id: ID
  name: String
}

input PriceUpdateDataInput {
  amount: Float
  currency: CurrencyUpdateOneInput
  type: PriceTypeUpdateOneInput
}

input PriceUpdateInput {
  amount: Float
  currency: CurrencyUpdateOneInput
  type: PriceTypeUpdateOneInput
}

input PriceUpdateManyInput {
  create: [PriceCreateInput!]
  connect: [PriceWhereUniqueInput!]
  disconnect: [PriceWhereUniqueInput!]
  delete: [PriceWhereUniqueInput!]
  update: [PriceUpdateWithWhereUniqueNestedInput!]
  upsert: [PriceUpsertWithWhereUniqueNestedInput!]
}

input PriceUpdateWithWhereUniqueNestedInput {
  where: PriceWhereUniqueInput!
  data: PriceUpdateDataInput!
}

input PriceUpsertWithWhereUniqueNestedInput {
  where: PriceWhereUniqueInput!
  update: PriceUpdateDataInput!
  create: PriceCreateInput!
}

input PriceWhereInput {
  """Logical AND on all given filters."""
  AND: [PriceWhereInput!]

  """Logical OR on all given filters."""
  OR: [PriceWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [PriceWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  amount: Float

  """All values that are not equal to given value."""
  amount_not: Float

  """All values that are contained in given list."""
  amount_in: [Float!]

  """All values that are not contained in given list."""
  amount_not_in: [Float!]

  """All values less than the given value."""
  amount_lt: Float

  """All values less than or equal the given value."""
  amount_lte: Float

  """All values greater than the given value."""
  amount_gt: Float

  """All values greater than or equal the given value."""
  amount_gte: Float
  currency: CurrencyWhereInput
  type: PriceTypeWhereInput
  _MagicalBackRelation_PriceToRoom_every: RoomWhereInput
  _MagicalBackRelation_PriceToRoom_some: RoomWhereInput
  _MagicalBackRelation_PriceToRoom_none: RoomWhereInput
}

input PriceWhereUniqueInput {
  id: ID
}

type Promo implements Node {
  id: ID!
  code: String!
  description: String
  off: Float!
  unit: Unit!
}

"""A connection to a list of items."""
type PromoConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [PromoEdge]!
  aggregate: AggregatePromo!
}

input PromoCreateInput {
  code: String!
  description: String
  off: Float!
  unit: Unit!
}

input PromoCreateManyInput {
  create: [PromoCreateInput!]
  connect: [PromoWhereUniqueInput!]
}

"""An edge in a connection."""
type PromoEdge {
  """The item at the end of the edge."""
  node: Promo!

  """A cursor for use in pagination."""
  cursor: String!
}

enum PromoOrderByInput {
  id_ASC
  id_DESC
  code_ASC
  code_DESC
  description_ASC
  description_DESC
  off_ASC
  off_DESC
  unit_ASC
  unit_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type PromoPreviousValues {
  id: ID!
  code: String!
  description: String
  off: Float!
  unit: Unit!
}

type PromoSubscriptionPayload {
  mutation: MutationType!
  node: Promo
  updatedFields: [String!]
  previousValues: PromoPreviousValues
}

input PromoSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [PromoSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [PromoSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [PromoSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: PromoWhereInput
}

input PromoUpdateDataInput {
  code: String
  description: String
  off: Float
  unit: Unit
}

input PromoUpdateInput {
  code: String
  description: String
  off: Float
  unit: Unit
}

input PromoUpdateManyInput {
  create: [PromoCreateInput!]
  connect: [PromoWhereUniqueInput!]
  disconnect: [PromoWhereUniqueInput!]
  delete: [PromoWhereUniqueInput!]
  update: [PromoUpdateWithWhereUniqueNestedInput!]
  upsert: [PromoUpsertWithWhereUniqueNestedInput!]
}

input PromoUpdateWithWhereUniqueNestedInput {
  where: PromoWhereUniqueInput!
  data: PromoUpdateDataInput!
}

input PromoUpsertWithWhereUniqueNestedInput {
  where: PromoWhereUniqueInput!
  update: PromoUpdateDataInput!
  create: PromoCreateInput!
}

input PromoWhereInput {
  """Logical AND on all given filters."""
  AND: [PromoWhereInput!]

  """Logical OR on all given filters."""
  OR: [PromoWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [PromoWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  code: String

  """All values that are not equal to given value."""
  code_not: String

  """All values that are contained in given list."""
  code_in: [String!]

  """All values that are not contained in given list."""
  code_not_in: [String!]

  """All values less than the given value."""
  code_lt: String

  """All values less than or equal the given value."""
  code_lte: String

  """All values greater than the given value."""
  code_gt: String

  """All values greater than or equal the given value."""
  code_gte: String

  """All values containing the given string."""
  code_contains: String

  """All values not containing the given string."""
  code_not_contains: String

  """All values starting with the given string."""
  code_starts_with: String

  """All values not starting with the given string."""
  code_not_starts_with: String

  """All values ending with the given string."""
  code_ends_with: String

  """All values not ending with the given string."""
  code_not_ends_with: String
  description: String

  """All values that are not equal to given value."""
  description_not: String

  """All values that are contained in given list."""
  description_in: [String!]

  """All values that are not contained in given list."""
  description_not_in: [String!]

  """All values less than the given value."""
  description_lt: String

  """All values less than or equal the given value."""
  description_lte: String

  """All values greater than the given value."""
  description_gt: String

  """All values greater than or equal the given value."""
  description_gte: String

  """All values containing the given string."""
  description_contains: String

  """All values not containing the given string."""
  description_not_contains: String

  """All values starting with the given string."""
  description_starts_with: String

  """All values not starting with the given string."""
  description_not_starts_with: String

  """All values ending with the given string."""
  description_ends_with: String

  """All values not ending with the given string."""
  description_not_ends_with: String
  off: Float

  """All values that are not equal to given value."""
  off_not: Float

  """All values that are contained in given list."""
  off_in: [Float!]

  """All values that are not contained in given list."""
  off_not_in: [Float!]

  """All values less than the given value."""
  off_lt: Float

  """All values less than or equal the given value."""
  off_lte: Float

  """All values greater than the given value."""
  off_gt: Float

  """All values greater than or equal the given value."""
  off_gte: Float
  unit: Unit

  """All values that are not equal to given value."""
  unit_not: Unit

  """All values that are contained in given list."""
  unit_in: [Unit!]

  """All values that are not contained in given list."""
  unit_not_in: [Unit!]
  _MagicalBackRelation_OrderToPromo_every: OrderWhereInput
  _MagicalBackRelation_OrderToPromo_some: OrderWhereInput
  _MagicalBackRelation_OrderToPromo_none: OrderWhereInput
}

input PromoWhereUniqueInput {
  id: ID
}

type Property implements Node {
  id: ID!
  owner(where: CustomerWhereInput): Customer!
  name: String!
  about: String
  logo: String
  photos: [String!]!
  address(where: AddressWhereInput): Address!
  phone: String!
  email: String!
  reviews(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Review!]
  rooms(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Room!]
  policies(where: PolicyWhereInput, orderBy: PolicyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Policy!]
  categories(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category!]
  facilities(where: PropertyFacilityWhereInput, orderBy: PropertyFacilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PropertyFacility!]
}

"""A connection to a list of items."""
type PropertyConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [PropertyEdge]!
  aggregate: AggregateProperty!
}

input PropertyCreateInput {
  name: String!
  about: String
  logo: String
  phone: String!
  email: String!
  photos: PropertyCreatephotosInput
  owner: CustomerCreateOneWithoutPropertiesInput!
  address: AddressCreateOneInput!
  reviews: ReviewCreateManyWithoutForInput
  rooms: RoomCreateManyWithoutPropertyInput
  policies: PolicyCreateManyWithoutPropertiesInput
  categories: CategoryCreateManyWithoutPropertiesInput
  facilities: PropertyFacilityCreateManyWithoutPropertyInput
}

input PropertyCreateManyWithoutCategoriesInput {
  create: [PropertyCreateWithoutCategoriesInput!]
  connect: [PropertyWhereUniqueInput!]
}

input PropertyCreateManyWithoutOwnerInput {
  create: [PropertyCreateWithoutOwnerInput!]
  connect: [PropertyWhereUniqueInput!]
}

input PropertyCreateManyWithoutPoliciesInput {
  create: [PropertyCreateWithoutPoliciesInput!]
  connect: [PropertyWhereUniqueInput!]
}

input PropertyCreateOneWithoutFacilitiesInput {
  create: PropertyCreateWithoutFacilitiesInput
  connect: PropertyWhereUniqueInput
}

input PropertyCreateOneWithoutReviewsInput {
  create: PropertyCreateWithoutReviewsInput
  connect: PropertyWhereUniqueInput
}

input PropertyCreateOneWithoutRoomsInput {
  create: PropertyCreateWithoutRoomsInput
  connect: PropertyWhereUniqueInput
}

input PropertyCreatephotosInput {
  set: [String!]
}

input PropertyCreateWithoutCategoriesInput {
  name: String!
  about: String
  logo: String
  phone: String!
  email: String!
  photos: PropertyCreatephotosInput
  owner: CustomerCreateOneWithoutPropertiesInput!
  address: AddressCreateOneInput!
  reviews: ReviewCreateManyWithoutForInput
  rooms: RoomCreateManyWithoutPropertyInput
  policies: PolicyCreateManyWithoutPropertiesInput
  facilities: PropertyFacilityCreateManyWithoutPropertyInput
}

input PropertyCreateWithoutFacilitiesInput {
  name: String!
  about: String
  logo: String
  phone: String!
  email: String!
  photos: PropertyCreatephotosInput
  owner: CustomerCreateOneWithoutPropertiesInput!
  address: AddressCreateOneInput!
  reviews: ReviewCreateManyWithoutForInput
  rooms: RoomCreateManyWithoutPropertyInput
  policies: PolicyCreateManyWithoutPropertiesInput
  categories: CategoryCreateManyWithoutPropertiesInput
}

input PropertyCreateWithoutOwnerInput {
  name: String!
  about: String
  logo: String
  phone: String!
  email: String!
  photos: PropertyCreatephotosInput
  address: AddressCreateOneInput!
  reviews: ReviewCreateManyWithoutForInput
  rooms: RoomCreateManyWithoutPropertyInput
  policies: PolicyCreateManyWithoutPropertiesInput
  categories: CategoryCreateManyWithoutPropertiesInput
  facilities: PropertyFacilityCreateManyWithoutPropertyInput
}

input PropertyCreateWithoutPoliciesInput {
  name: String!
  about: String
  logo: String
  phone: String!
  email: String!
  photos: PropertyCreatephotosInput
  owner: CustomerCreateOneWithoutPropertiesInput!
  address: AddressCreateOneInput!
  reviews: ReviewCreateManyWithoutForInput
  rooms: RoomCreateManyWithoutPropertyInput
  categories: CategoryCreateManyWithoutPropertiesInput
  facilities: PropertyFacilityCreateManyWithoutPropertyInput
}

input PropertyCreateWithoutReviewsInput {
  name: String!
  about: String
  logo: String
  phone: String!
  email: String!
  photos: PropertyCreatephotosInput
  owner: CustomerCreateOneWithoutPropertiesInput!
  address: AddressCreateOneInput!
  rooms: RoomCreateManyWithoutPropertyInput
  policies: PolicyCreateManyWithoutPropertiesInput
  categories: CategoryCreateManyWithoutPropertiesInput
  facilities: PropertyFacilityCreateManyWithoutPropertyInput
}

input PropertyCreateWithoutRoomsInput {
  name: String!
  about: String
  logo: String
  phone: String!
  email: String!
  photos: PropertyCreatephotosInput
  owner: CustomerCreateOneWithoutPropertiesInput!
  address: AddressCreateOneInput!
  reviews: ReviewCreateManyWithoutForInput
  policies: PolicyCreateManyWithoutPropertiesInput
  categories: CategoryCreateManyWithoutPropertiesInput
  facilities: PropertyFacilityCreateManyWithoutPropertyInput
}

"""An edge in a connection."""
type PropertyEdge {
  """The item at the end of the edge."""
  node: Property!

  """A cursor for use in pagination."""
  cursor: String!
}

type PropertyFacility implements Node {
  id: ID!
  property(where: PropertyWhereInput): Property!
  facility(where: FacilityWhereInput): Facility!
  description: String
  isComplimentary: Boolean
}

"""A connection to a list of items."""
type PropertyFacilityConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [PropertyFacilityEdge]!
  aggregate: AggregatePropertyFacility!
}

input PropertyFacilityCreateInput {
  description: String
  isComplimentary: Boolean
  property: PropertyCreateOneWithoutFacilitiesInput!
  facility: FacilityCreateOneWithoutPropertiesInput!
}

input PropertyFacilityCreateManyWithoutFacilityInput {
  create: [PropertyFacilityCreateWithoutFacilityInput!]
  connect: [PropertyFacilityWhereUniqueInput!]
}

input PropertyFacilityCreateManyWithoutPropertyInput {
  create: [PropertyFacilityCreateWithoutPropertyInput!]
  connect: [PropertyFacilityWhereUniqueInput!]
}

input PropertyFacilityCreateWithoutFacilityInput {
  description: String
  isComplimentary: Boolean
  property: PropertyCreateOneWithoutFacilitiesInput!
}

input PropertyFacilityCreateWithoutPropertyInput {
  description: String
  isComplimentary: Boolean
  facility: FacilityCreateOneWithoutPropertiesInput!
}

"""An edge in a connection."""
type PropertyFacilityEdge {
  """The item at the end of the edge."""
  node: PropertyFacility!

  """A cursor for use in pagination."""
  cursor: String!
}

enum PropertyFacilityOrderByInput {
  id_ASC
  id_DESC
  description_ASC
  description_DESC
  isComplimentary_ASC
  isComplimentary_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type PropertyFacilityPreviousValues {
  id: ID!
  description: String
  isComplimentary: Boolean
}

type PropertyFacilitySubscriptionPayload {
  mutation: MutationType!
  node: PropertyFacility
  updatedFields: [String!]
  previousValues: PropertyFacilityPreviousValues
}

input PropertyFacilitySubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [PropertyFacilitySubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [PropertyFacilitySubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [PropertyFacilitySubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: PropertyFacilityWhereInput
}

input PropertyFacilityUpdateInput {
  description: String
  isComplimentary: Boolean
  property: PropertyUpdateOneWithoutFacilitiesInput
  facility: FacilityUpdateOneWithoutPropertiesInput
}

input PropertyFacilityUpdateManyWithoutFacilityInput {
  create: [PropertyFacilityCreateWithoutFacilityInput!]
  connect: [PropertyFacilityWhereUniqueInput!]
  disconnect: [PropertyFacilityWhereUniqueInput!]
  delete: [PropertyFacilityWhereUniqueInput!]
  update: [PropertyFacilityUpdateWithWhereUniqueWithoutFacilityInput!]
  upsert: [PropertyFacilityUpsertWithWhereUniqueWithoutFacilityInput!]
}

input PropertyFacilityUpdateManyWithoutPropertyInput {
  create: [PropertyFacilityCreateWithoutPropertyInput!]
  connect: [PropertyFacilityWhereUniqueInput!]
  disconnect: [PropertyFacilityWhereUniqueInput!]
  delete: [PropertyFacilityWhereUniqueInput!]
  update: [PropertyFacilityUpdateWithWhereUniqueWithoutPropertyInput!]
  upsert: [PropertyFacilityUpsertWithWhereUniqueWithoutPropertyInput!]
}

input PropertyFacilityUpdateWithoutFacilityDataInput {
  description: String
  isComplimentary: Boolean
  property: PropertyUpdateOneWithoutFacilitiesInput
}

input PropertyFacilityUpdateWithoutPropertyDataInput {
  description: String
  isComplimentary: Boolean
  facility: FacilityUpdateOneWithoutPropertiesInput
}

input PropertyFacilityUpdateWithWhereUniqueWithoutFacilityInput {
  where: PropertyFacilityWhereUniqueInput!
  data: PropertyFacilityUpdateWithoutFacilityDataInput!
}

input PropertyFacilityUpdateWithWhereUniqueWithoutPropertyInput {
  where: PropertyFacilityWhereUniqueInput!
  data: PropertyFacilityUpdateWithoutPropertyDataInput!
}

input PropertyFacilityUpsertWithWhereUniqueWithoutFacilityInput {
  where: PropertyFacilityWhereUniqueInput!
  update: PropertyFacilityUpdateWithoutFacilityDataInput!
  create: PropertyFacilityCreateWithoutFacilityInput!
}

input PropertyFacilityUpsertWithWhereUniqueWithoutPropertyInput {
  where: PropertyFacilityWhereUniqueInput!
  update: PropertyFacilityUpdateWithoutPropertyDataInput!
  create: PropertyFacilityCreateWithoutPropertyInput!
}

input PropertyFacilityWhereInput {
  """Logical AND on all given filters."""
  AND: [PropertyFacilityWhereInput!]

  """Logical OR on all given filters."""
  OR: [PropertyFacilityWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [PropertyFacilityWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  description: String

  """All values that are not equal to given value."""
  description_not: String

  """All values that are contained in given list."""
  description_in: [String!]

  """All values that are not contained in given list."""
  description_not_in: [String!]

  """All values less than the given value."""
  description_lt: String

  """All values less than or equal the given value."""
  description_lte: String

  """All values greater than the given value."""
  description_gt: String

  """All values greater than or equal the given value."""
  description_gte: String

  """All values containing the given string."""
  description_contains: String

  """All values not containing the given string."""
  description_not_contains: String

  """All values starting with the given string."""
  description_starts_with: String

  """All values not starting with the given string."""
  description_not_starts_with: String

  """All values ending with the given string."""
  description_ends_with: String

  """All values not ending with the given string."""
  description_not_ends_with: String
  isComplimentary: Boolean

  """All values that are not equal to given value."""
  isComplimentary_not: Boolean
  property: PropertyWhereInput
  facility: FacilityWhereInput
}

input PropertyFacilityWhereUniqueInput {
  id: ID
}

enum PropertyOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  about_ASC
  about_DESC
  logo_ASC
  logo_DESC
  phone_ASC
  phone_DESC
  email_ASC
  email_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type PropertyPreviousValues {
  id: ID!
  name: String!
  about: String
  logo: String
  photos: [String!]!
  phone: String!
  email: String!
}

type PropertySubscriptionPayload {
  mutation: MutationType!
  node: Property
  updatedFields: [String!]
  previousValues: PropertyPreviousValues
}

input PropertySubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [PropertySubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [PropertySubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [PropertySubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: PropertyWhereInput
}

input PropertyUpdateInput {
  name: String
  about: String
  logo: String
  phone: String
  email: String
  photos: PropertyUpdatephotosInput
  owner: CustomerUpdateOneWithoutPropertiesInput
  address: AddressUpdateOneInput
  reviews: ReviewUpdateManyWithoutForInput
  rooms: RoomUpdateManyWithoutPropertyInput
  policies: PolicyUpdateManyWithoutPropertiesInput
  categories: CategoryUpdateManyWithoutPropertiesInput
  facilities: PropertyFacilityUpdateManyWithoutPropertyInput
}

input PropertyUpdateManyWithoutCategoriesInput {
  create: [PropertyCreateWithoutCategoriesInput!]
  connect: [PropertyWhereUniqueInput!]
  disconnect: [PropertyWhereUniqueInput!]
  delete: [PropertyWhereUniqueInput!]
  update: [PropertyUpdateWithWhereUniqueWithoutCategoriesInput!]
  upsert: [PropertyUpsertWithWhereUniqueWithoutCategoriesInput!]
}

input PropertyUpdateManyWithoutOwnerInput {
  create: [PropertyCreateWithoutOwnerInput!]
  connect: [PropertyWhereUniqueInput!]
  disconnect: [PropertyWhereUniqueInput!]
  delete: [PropertyWhereUniqueInput!]
  update: [PropertyUpdateWithWhereUniqueWithoutOwnerInput!]
  upsert: [PropertyUpsertWithWhereUniqueWithoutOwnerInput!]
}

input PropertyUpdateManyWithoutPoliciesInput {
  create: [PropertyCreateWithoutPoliciesInput!]
  connect: [PropertyWhereUniqueInput!]
  disconnect: [PropertyWhereUniqueInput!]
  delete: [PropertyWhereUniqueInput!]
  update: [PropertyUpdateWithWhereUniqueWithoutPoliciesInput!]
  upsert: [PropertyUpsertWithWhereUniqueWithoutPoliciesInput!]
}

input PropertyUpdateOneWithoutFacilitiesInput {
  create: PropertyCreateWithoutFacilitiesInput
  connect: PropertyWhereUniqueInput
  delete: Boolean
  update: PropertyUpdateWithoutFacilitiesDataInput
  upsert: PropertyUpsertWithoutFacilitiesInput
}

input PropertyUpdateOneWithoutReviewsInput {
  create: PropertyCreateWithoutReviewsInput
  connect: PropertyWhereUniqueInput
  delete: Boolean
  update: PropertyUpdateWithoutReviewsDataInput
  upsert: PropertyUpsertWithoutReviewsInput
}

input PropertyUpdateOneWithoutRoomsInput {
  create: PropertyCreateWithoutRoomsInput
  connect: PropertyWhereUniqueInput
  delete: Boolean
  update: PropertyUpdateWithoutRoomsDataInput
  upsert: PropertyUpsertWithoutRoomsInput
}

input PropertyUpdatephotosInput {
  set: [String!]
}

input PropertyUpdateWithoutCategoriesDataInput {
  name: String
  about: String
  logo: String
  phone: String
  email: String
  photos: PropertyUpdatephotosInput
  owner: CustomerUpdateOneWithoutPropertiesInput
  address: AddressUpdateOneInput
  reviews: ReviewUpdateManyWithoutForInput
  rooms: RoomUpdateManyWithoutPropertyInput
  policies: PolicyUpdateManyWithoutPropertiesInput
  facilities: PropertyFacilityUpdateManyWithoutPropertyInput
}

input PropertyUpdateWithoutFacilitiesDataInput {
  name: String
  about: String
  logo: String
  phone: String
  email: String
  photos: PropertyUpdatephotosInput
  owner: CustomerUpdateOneWithoutPropertiesInput
  address: AddressUpdateOneInput
  reviews: ReviewUpdateManyWithoutForInput
  rooms: RoomUpdateManyWithoutPropertyInput
  policies: PolicyUpdateManyWithoutPropertiesInput
  categories: CategoryUpdateManyWithoutPropertiesInput
}

input PropertyUpdateWithoutOwnerDataInput {
  name: String
  about: String
  logo: String
  phone: String
  email: String
  photos: PropertyUpdatephotosInput
  address: AddressUpdateOneInput
  reviews: ReviewUpdateManyWithoutForInput
  rooms: RoomUpdateManyWithoutPropertyInput
  policies: PolicyUpdateManyWithoutPropertiesInput
  categories: CategoryUpdateManyWithoutPropertiesInput
  facilities: PropertyFacilityUpdateManyWithoutPropertyInput
}

input PropertyUpdateWithoutPoliciesDataInput {
  name: String
  about: String
  logo: String
  phone: String
  email: String
  photos: PropertyUpdatephotosInput
  owner: CustomerUpdateOneWithoutPropertiesInput
  address: AddressUpdateOneInput
  reviews: ReviewUpdateManyWithoutForInput
  rooms: RoomUpdateManyWithoutPropertyInput
  categories: CategoryUpdateManyWithoutPropertiesInput
  facilities: PropertyFacilityUpdateManyWithoutPropertyInput
}

input PropertyUpdateWithoutReviewsDataInput {
  name: String
  about: String
  logo: String
  phone: String
  email: String
  photos: PropertyUpdatephotosInput
  owner: CustomerUpdateOneWithoutPropertiesInput
  address: AddressUpdateOneInput
  rooms: RoomUpdateManyWithoutPropertyInput
  policies: PolicyUpdateManyWithoutPropertiesInput
  categories: CategoryUpdateManyWithoutPropertiesInput
  facilities: PropertyFacilityUpdateManyWithoutPropertyInput
}

input PropertyUpdateWithoutRoomsDataInput {
  name: String
  about: String
  logo: String
  phone: String
  email: String
  photos: PropertyUpdatephotosInput
  owner: CustomerUpdateOneWithoutPropertiesInput
  address: AddressUpdateOneInput
  reviews: ReviewUpdateManyWithoutForInput
  policies: PolicyUpdateManyWithoutPropertiesInput
  categories: CategoryUpdateManyWithoutPropertiesInput
  facilities: PropertyFacilityUpdateManyWithoutPropertyInput
}

input PropertyUpdateWithWhereUniqueWithoutCategoriesInput {
  where: PropertyWhereUniqueInput!
  data: PropertyUpdateWithoutCategoriesDataInput!
}

input PropertyUpdateWithWhereUniqueWithoutOwnerInput {
  where: PropertyWhereUniqueInput!
  data: PropertyUpdateWithoutOwnerDataInput!
}

input PropertyUpdateWithWhereUniqueWithoutPoliciesInput {
  where: PropertyWhereUniqueInput!
  data: PropertyUpdateWithoutPoliciesDataInput!
}

input PropertyUpsertWithoutFacilitiesInput {
  update: PropertyUpdateWithoutFacilitiesDataInput!
  create: PropertyCreateWithoutFacilitiesInput!
}

input PropertyUpsertWithoutReviewsInput {
  update: PropertyUpdateWithoutReviewsDataInput!
  create: PropertyCreateWithoutReviewsInput!
}

input PropertyUpsertWithoutRoomsInput {
  update: PropertyUpdateWithoutRoomsDataInput!
  create: PropertyCreateWithoutRoomsInput!
}

input PropertyUpsertWithWhereUniqueWithoutCategoriesInput {
  where: PropertyWhereUniqueInput!
  update: PropertyUpdateWithoutCategoriesDataInput!
  create: PropertyCreateWithoutCategoriesInput!
}

input PropertyUpsertWithWhereUniqueWithoutOwnerInput {
  where: PropertyWhereUniqueInput!
  update: PropertyUpdateWithoutOwnerDataInput!
  create: PropertyCreateWithoutOwnerInput!
}

input PropertyUpsertWithWhereUniqueWithoutPoliciesInput {
  where: PropertyWhereUniqueInput!
  update: PropertyUpdateWithoutPoliciesDataInput!
  create: PropertyCreateWithoutPoliciesInput!
}

input PropertyWhereInput {
  """Logical AND on all given filters."""
  AND: [PropertyWhereInput!]

  """Logical OR on all given filters."""
  OR: [PropertyWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [PropertyWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  about: String

  """All values that are not equal to given value."""
  about_not: String

  """All values that are contained in given list."""
  about_in: [String!]

  """All values that are not contained in given list."""
  about_not_in: [String!]

  """All values less than the given value."""
  about_lt: String

  """All values less than or equal the given value."""
  about_lte: String

  """All values greater than the given value."""
  about_gt: String

  """All values greater than or equal the given value."""
  about_gte: String

  """All values containing the given string."""
  about_contains: String

  """All values not containing the given string."""
  about_not_contains: String

  """All values starting with the given string."""
  about_starts_with: String

  """All values not starting with the given string."""
  about_not_starts_with: String

  """All values ending with the given string."""
  about_ends_with: String

  """All values not ending with the given string."""
  about_not_ends_with: String
  logo: String

  """All values that are not equal to given value."""
  logo_not: String

  """All values that are contained in given list."""
  logo_in: [String!]

  """All values that are not contained in given list."""
  logo_not_in: [String!]

  """All values less than the given value."""
  logo_lt: String

  """All values less than or equal the given value."""
  logo_lte: String

  """All values greater than the given value."""
  logo_gt: String

  """All values greater than or equal the given value."""
  logo_gte: String

  """All values containing the given string."""
  logo_contains: String

  """All values not containing the given string."""
  logo_not_contains: String

  """All values starting with the given string."""
  logo_starts_with: String

  """All values not starting with the given string."""
  logo_not_starts_with: String

  """All values ending with the given string."""
  logo_ends_with: String

  """All values not ending with the given string."""
  logo_not_ends_with: String
  phone: String

  """All values that are not equal to given value."""
  phone_not: String

  """All values that are contained in given list."""
  phone_in: [String!]

  """All values that are not contained in given list."""
  phone_not_in: [String!]

  """All values less than the given value."""
  phone_lt: String

  """All values less than or equal the given value."""
  phone_lte: String

  """All values greater than the given value."""
  phone_gt: String

  """All values greater than or equal the given value."""
  phone_gte: String

  """All values containing the given string."""
  phone_contains: String

  """All values not containing the given string."""
  phone_not_contains: String

  """All values starting with the given string."""
  phone_starts_with: String

  """All values not starting with the given string."""
  phone_not_starts_with: String

  """All values ending with the given string."""
  phone_ends_with: String

  """All values not ending with the given string."""
  phone_not_ends_with: String
  email: String

  """All values that are not equal to given value."""
  email_not: String

  """All values that are contained in given list."""
  email_in: [String!]

  """All values that are not contained in given list."""
  email_not_in: [String!]

  """All values less than the given value."""
  email_lt: String

  """All values less than or equal the given value."""
  email_lte: String

  """All values greater than the given value."""
  email_gt: String

  """All values greater than or equal the given value."""
  email_gte: String

  """All values containing the given string."""
  email_contains: String

  """All values not containing the given string."""
  email_not_contains: String

  """All values starting with the given string."""
  email_starts_with: String

  """All values not starting with the given string."""
  email_not_starts_with: String

  """All values ending with the given string."""
  email_ends_with: String

  """All values not ending with the given string."""
  email_not_ends_with: String
  owner: CustomerWhereInput
  address: AddressWhereInput
  reviews_every: ReviewWhereInput
  reviews_some: ReviewWhereInput
  reviews_none: ReviewWhereInput
  rooms_every: RoomWhereInput
  rooms_some: RoomWhereInput
  rooms_none: RoomWhereInput
  policies_every: PolicyWhereInput
  policies_some: PolicyWhereInput
  policies_none: PolicyWhereInput
  categories_every: CategoryWhereInput
  categories_some: CategoryWhereInput
  categories_none: CategoryWhereInput
  facilities_every: PropertyFacilityWhereInput
  facilities_some: PropertyFacilityWhereInput
  facilities_none: PropertyFacilityWhereInput
}

input PropertyWhereUniqueInput {
  id: ID
}

type Query {
  customers(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Customer]!
  properties(where: PropertyWhereInput, orderBy: PropertyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Property]!
  categories(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category]!
  rooms(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Room]!
  beds(where: BedWhereInput, orderBy: BedOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Bed]!
  bedTypes(where: BedTypeWhereInput, orderBy: BedTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BedType]!
  facilities(where: FacilityWhereInput, orderBy: FacilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Facility]!
  propertyFacilities(where: PropertyFacilityWhereInput, orderBy: PropertyFacilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PropertyFacility]!
  facilityTypes(where: FacilityTypeWhereInput, orderBy: FacilityTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FacilityType]!
  policies(where: PolicyWhereInput, orderBy: PolicyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Policy]!
  reviews(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Review]!
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order]!
  timezones(where: TimezoneWhereInput, orderBy: TimezoneOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Timezone]!
  languages(where: LanguageWhereInput, orderBy: LanguageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Language]!
  preferences(where: PreferenceWhereInput, orderBy: PreferenceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Preference]!
  taxes(where: TaxWhereInput, orderBy: TaxOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tax]!
  promoes(where: PromoWhereInput, orderBy: PromoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Promo]!
  bookings(where: BookingWhereInput, orderBy: BookingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Booking]!
  countries(where: CountryWhereInput, orderBy: CountryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Country]!
  addresses(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Address]!
  priceTypes(where: PriceTypeWhereInput, orderBy: PriceTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PriceType]!
  prices(where: PriceWhereInput, orderBy: PriceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Price]!
  currencies(where: CurrencyWhereInput, orderBy: CurrencyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Currency]!
  customer(where: CustomerWhereUniqueInput!): Customer
  property(where: PropertyWhereUniqueInput!): Property
  category(where: CategoryWhereUniqueInput!): Category
  room(where: RoomWhereUniqueInput!): Room
  bed(where: BedWhereUniqueInput!): Bed
  bedType(where: BedTypeWhereUniqueInput!): BedType
  facility(where: FacilityWhereUniqueInput!): Facility
  propertyFacility(where: PropertyFacilityWhereUniqueInput!): PropertyFacility
  facilityType(where: FacilityTypeWhereUniqueInput!): FacilityType
  policy(where: PolicyWhereUniqueInput!): Policy
  review(where: ReviewWhereUniqueInput!): Review
  order(where: OrderWhereUniqueInput!): Order
  timezone(where: TimezoneWhereUniqueInput!): Timezone
  language(where: LanguageWhereUniqueInput!): Language
  preference(where: PreferenceWhereUniqueInput!): Preference
  tax(where: TaxWhereUniqueInput!): Tax
  promo(where: PromoWhereUniqueInput!): Promo
  booking(where: BookingWhereUniqueInput!): Booking
  country(where: CountryWhereUniqueInput!): Country
  address(where: AddressWhereUniqueInput!): Address
  priceType(where: PriceTypeWhereUniqueInput!): PriceType
  price(where: PriceWhereUniqueInput!): Price
  currency(where: CurrencyWhereUniqueInput!): Currency
  customersConnection(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CustomerConnection!
  propertiesConnection(where: PropertyWhereInput, orderBy: PropertyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PropertyConnection!
  categoriesConnection(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CategoryConnection!
  roomsConnection(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RoomConnection!
  bedsConnection(where: BedWhereInput, orderBy: BedOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BedConnection!
  bedTypesConnection(where: BedTypeWhereInput, orderBy: BedTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BedTypeConnection!
  facilitiesConnection(where: FacilityWhereInput, orderBy: FacilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FacilityConnection!
  propertyFacilitiesConnection(where: PropertyFacilityWhereInput, orderBy: PropertyFacilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PropertyFacilityConnection!
  facilityTypesConnection(where: FacilityTypeWhereInput, orderBy: FacilityTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FacilityTypeConnection!
  policiesConnection(where: PolicyWhereInput, orderBy: PolicyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PolicyConnection!
  reviewsConnection(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ReviewConnection!
  ordersConnection(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrderConnection!
  timezonesConnection(where: TimezoneWhereInput, orderBy: TimezoneOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TimezoneConnection!
  languagesConnection(where: LanguageWhereInput, orderBy: LanguageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LanguageConnection!
  preferencesConnection(where: PreferenceWhereInput, orderBy: PreferenceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PreferenceConnection!
  taxesConnection(where: TaxWhereInput, orderBy: TaxOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TaxConnection!
  promoesConnection(where: PromoWhereInput, orderBy: PromoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PromoConnection!
  bookingsConnection(where: BookingWhereInput, orderBy: BookingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BookingConnection!
  countriesConnection(where: CountryWhereInput, orderBy: CountryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CountryConnection!
  addressesConnection(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AddressConnection!
  priceTypesConnection(where: PriceTypeWhereInput, orderBy: PriceTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PriceTypeConnection!
  pricesConnection(where: PriceWhereInput, orderBy: PriceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PriceConnection!
  currenciesConnection(where: CurrencyWhereInput, orderBy: CurrencyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CurrencyConnection!

  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node
}

type Review implements Node {
  id: ID!
  rating: Float!
  comment: String
  by(where: CustomerWhereInput): Customer!
  for(where: PropertyWhereInput): Property!
  upVotes(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Customer!]
  downVotes(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Customer!]
}

"""A connection to a list of items."""
type ReviewConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [ReviewEdge]!
  aggregate: AggregateReview!
}

input ReviewCreateInput {
  rating: Float!
  comment: String
  by: CustomerCreateOneWithoutReviewsInput!
  for: PropertyCreateOneWithoutReviewsInput!
  upVotes: CustomerCreateManyWithoutLikedReviewsInput
  downVotes: CustomerCreateManyWithoutDislikedReviewsInput
}

input ReviewCreateManyWithoutByInput {
  create: [ReviewCreateWithoutByInput!]
  connect: [ReviewWhereUniqueInput!]
}

input ReviewCreateManyWithoutDownVotesInput {
  create: [ReviewCreateWithoutDownVotesInput!]
  connect: [ReviewWhereUniqueInput!]
}

input ReviewCreateManyWithoutForInput {
  create: [ReviewCreateWithoutForInput!]
  connect: [ReviewWhereUniqueInput!]
}

input ReviewCreateManyWithoutUpVotesInput {
  create: [ReviewCreateWithoutUpVotesInput!]
  connect: [ReviewWhereUniqueInput!]
}

input ReviewCreateWithoutByInput {
  rating: Float!
  comment: String
  for: PropertyCreateOneWithoutReviewsInput!
  upVotes: CustomerCreateManyWithoutLikedReviewsInput
  downVotes: CustomerCreateManyWithoutDislikedReviewsInput
}

input ReviewCreateWithoutDownVotesInput {
  rating: Float!
  comment: String
  by: CustomerCreateOneWithoutReviewsInput!
  for: PropertyCreateOneWithoutReviewsInput!
  upVotes: CustomerCreateManyWithoutLikedReviewsInput
}

input ReviewCreateWithoutForInput {
  rating: Float!
  comment: String
  by: CustomerCreateOneWithoutReviewsInput!
  upVotes: CustomerCreateManyWithoutLikedReviewsInput
  downVotes: CustomerCreateManyWithoutDislikedReviewsInput
}

input ReviewCreateWithoutUpVotesInput {
  rating: Float!
  comment: String
  by: CustomerCreateOneWithoutReviewsInput!
  for: PropertyCreateOneWithoutReviewsInput!
  downVotes: CustomerCreateManyWithoutDislikedReviewsInput
}

"""An edge in a connection."""
type ReviewEdge {
  """The item at the end of the edge."""
  node: Review!

  """A cursor for use in pagination."""
  cursor: String!
}

enum ReviewOrderByInput {
  id_ASC
  id_DESC
  rating_ASC
  rating_DESC
  comment_ASC
  comment_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type ReviewPreviousValues {
  id: ID!
  rating: Float!
  comment: String
}

type ReviewSubscriptionPayload {
  mutation: MutationType!
  node: Review
  updatedFields: [String!]
  previousValues: ReviewPreviousValues
}

input ReviewSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [ReviewSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [ReviewSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [ReviewSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: ReviewWhereInput
}

input ReviewUpdateInput {
  rating: Float
  comment: String
  by: CustomerUpdateOneWithoutReviewsInput
  for: PropertyUpdateOneWithoutReviewsInput
  upVotes: CustomerUpdateManyWithoutLikedReviewsInput
  downVotes: CustomerUpdateManyWithoutDislikedReviewsInput
}

input ReviewUpdateManyWithoutByInput {
  create: [ReviewCreateWithoutByInput!]
  connect: [ReviewWhereUniqueInput!]
  disconnect: [ReviewWhereUniqueInput!]
  delete: [ReviewWhereUniqueInput!]
  update: [ReviewUpdateWithWhereUniqueWithoutByInput!]
  upsert: [ReviewUpsertWithWhereUniqueWithoutByInput!]
}

input ReviewUpdateManyWithoutDownVotesInput {
  create: [ReviewCreateWithoutDownVotesInput!]
  connect: [ReviewWhereUniqueInput!]
  disconnect: [ReviewWhereUniqueInput!]
  delete: [ReviewWhereUniqueInput!]
  update: [ReviewUpdateWithWhereUniqueWithoutDownVotesInput!]
  upsert: [ReviewUpsertWithWhereUniqueWithoutDownVotesInput!]
}

input ReviewUpdateManyWithoutForInput {
  create: [ReviewCreateWithoutForInput!]
  connect: [ReviewWhereUniqueInput!]
  disconnect: [ReviewWhereUniqueInput!]
  delete: [ReviewWhereUniqueInput!]
  update: [ReviewUpdateWithWhereUniqueWithoutForInput!]
  upsert: [ReviewUpsertWithWhereUniqueWithoutForInput!]
}

input ReviewUpdateManyWithoutUpVotesInput {
  create: [ReviewCreateWithoutUpVotesInput!]
  connect: [ReviewWhereUniqueInput!]
  disconnect: [ReviewWhereUniqueInput!]
  delete: [ReviewWhereUniqueInput!]
  update: [ReviewUpdateWithWhereUniqueWithoutUpVotesInput!]
  upsert: [ReviewUpsertWithWhereUniqueWithoutUpVotesInput!]
}

input ReviewUpdateWithoutByDataInput {
  rating: Float
  comment: String
  for: PropertyUpdateOneWithoutReviewsInput
  upVotes: CustomerUpdateManyWithoutLikedReviewsInput
  downVotes: CustomerUpdateManyWithoutDislikedReviewsInput
}

input ReviewUpdateWithoutDownVotesDataInput {
  rating: Float
  comment: String
  by: CustomerUpdateOneWithoutReviewsInput
  for: PropertyUpdateOneWithoutReviewsInput
  upVotes: CustomerUpdateManyWithoutLikedReviewsInput
}

input ReviewUpdateWithoutForDataInput {
  rating: Float
  comment: String
  by: CustomerUpdateOneWithoutReviewsInput
  upVotes: CustomerUpdateManyWithoutLikedReviewsInput
  downVotes: CustomerUpdateManyWithoutDislikedReviewsInput
}

input ReviewUpdateWithoutUpVotesDataInput {
  rating: Float
  comment: String
  by: CustomerUpdateOneWithoutReviewsInput
  for: PropertyUpdateOneWithoutReviewsInput
  downVotes: CustomerUpdateManyWithoutDislikedReviewsInput
}

input ReviewUpdateWithWhereUniqueWithoutByInput {
  where: ReviewWhereUniqueInput!
  data: ReviewUpdateWithoutByDataInput!
}

input ReviewUpdateWithWhereUniqueWithoutDownVotesInput {
  where: ReviewWhereUniqueInput!
  data: ReviewUpdateWithoutDownVotesDataInput!
}

input ReviewUpdateWithWhereUniqueWithoutForInput {
  where: ReviewWhereUniqueInput!
  data: ReviewUpdateWithoutForDataInput!
}

input ReviewUpdateWithWhereUniqueWithoutUpVotesInput {
  where: ReviewWhereUniqueInput!
  data: ReviewUpdateWithoutUpVotesDataInput!
}

input ReviewUpsertWithWhereUniqueWithoutByInput {
  where: ReviewWhereUniqueInput!
  update: ReviewUpdateWithoutByDataInput!
  create: ReviewCreateWithoutByInput!
}

input ReviewUpsertWithWhereUniqueWithoutDownVotesInput {
  where: ReviewWhereUniqueInput!
  update: ReviewUpdateWithoutDownVotesDataInput!
  create: ReviewCreateWithoutDownVotesInput!
}

input ReviewUpsertWithWhereUniqueWithoutForInput {
  where: ReviewWhereUniqueInput!
  update: ReviewUpdateWithoutForDataInput!
  create: ReviewCreateWithoutForInput!
}

input ReviewUpsertWithWhereUniqueWithoutUpVotesInput {
  where: ReviewWhereUniqueInput!
  update: ReviewUpdateWithoutUpVotesDataInput!
  create: ReviewCreateWithoutUpVotesInput!
}

input ReviewWhereInput {
  """Logical AND on all given filters."""
  AND: [ReviewWhereInput!]

  """Logical OR on all given filters."""
  OR: [ReviewWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [ReviewWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  rating: Float

  """All values that are not equal to given value."""
  rating_not: Float

  """All values that are contained in given list."""
  rating_in: [Float!]

  """All values that are not contained in given list."""
  rating_not_in: [Float!]

  """All values less than the given value."""
  rating_lt: Float

  """All values less than or equal the given value."""
  rating_lte: Float

  """All values greater than the given value."""
  rating_gt: Float

  """All values greater than or equal the given value."""
  rating_gte: Float
  comment: String

  """All values that are not equal to given value."""
  comment_not: String

  """All values that are contained in given list."""
  comment_in: [String!]

  """All values that are not contained in given list."""
  comment_not_in: [String!]

  """All values less than the given value."""
  comment_lt: String

  """All values less than or equal the given value."""
  comment_lte: String

  """All values greater than the given value."""
  comment_gt: String

  """All values greater than or equal the given value."""
  comment_gte: String

  """All values containing the given string."""
  comment_contains: String

  """All values not containing the given string."""
  comment_not_contains: String

  """All values starting with the given string."""
  comment_starts_with: String

  """All values not starting with the given string."""
  comment_not_starts_with: String

  """All values ending with the given string."""
  comment_ends_with: String

  """All values not ending with the given string."""
  comment_not_ends_with: String
  by: CustomerWhereInput
  for: PropertyWhereInput
  upVotes_every: CustomerWhereInput
  upVotes_some: CustomerWhereInput
  upVotes_none: CustomerWhereInput
  downVotes_every: CustomerWhereInput
  downVotes_some: CustomerWhereInput
  downVotes_none: CustomerWhereInput
}

input ReviewWhereUniqueInput {
  id: ID
}

type Room implements Node {
  id: ID!
  name: String
  property(where: PropertyWhereInput): Property!
  photos: [String!]!
  prices(where: PriceWhereInput, orderBy: PriceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Price!]
  beds(where: BedWhereInput, orderBy: BedOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Bed!]
  facilities(where: FacilityWhereInput, orderBy: FacilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Facility!]
  bookings(where: BookingWhereInput, orderBy: BookingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Booking!]
  active: Boolean
}

"""A connection to a list of items."""
type RoomConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [RoomEdge]!
  aggregate: AggregateRoom!
}

input RoomCreateInput {
  name: String
  active: Boolean
  photos: RoomCreatephotosInput
  property: PropertyCreateOneWithoutRoomsInput!
  prices: PriceCreateManyInput
  beds: BedCreateManyWithoutRoomsInput
  facilities: FacilityCreateManyWithoutRoomsInput
  bookings: BookingCreateManyWithoutRoomsInput
}

input RoomCreateManyWithoutBedsInput {
  create: [RoomCreateWithoutBedsInput!]
  connect: [RoomWhereUniqueInput!]
}

input RoomCreateManyWithoutBookingsInput {
  create: [RoomCreateWithoutBookingsInput!]
  connect: [RoomWhereUniqueInput!]
}

input RoomCreateManyWithoutFacilitiesInput {
  create: [RoomCreateWithoutFacilitiesInput!]
  connect: [RoomWhereUniqueInput!]
}

input RoomCreateManyWithoutPropertyInput {
  create: [RoomCreateWithoutPropertyInput!]
  connect: [RoomWhereUniqueInput!]
}

input RoomCreatephotosInput {
  set: [String!]
}

input RoomCreateWithoutBedsInput {
  name: String
  active: Boolean
  photos: RoomCreatephotosInput
  property: PropertyCreateOneWithoutRoomsInput!
  prices: PriceCreateManyInput
  facilities: FacilityCreateManyWithoutRoomsInput
  bookings: BookingCreateManyWithoutRoomsInput
}

input RoomCreateWithoutBookingsInput {
  name: String
  active: Boolean
  photos: RoomCreatephotosInput
  property: PropertyCreateOneWithoutRoomsInput!
  prices: PriceCreateManyInput
  beds: BedCreateManyWithoutRoomsInput
  facilities: FacilityCreateManyWithoutRoomsInput
}

input RoomCreateWithoutFacilitiesInput {
  name: String
  active: Boolean
  photos: RoomCreatephotosInput
  property: PropertyCreateOneWithoutRoomsInput!
  prices: PriceCreateManyInput
  beds: BedCreateManyWithoutRoomsInput
  bookings: BookingCreateManyWithoutRoomsInput
}

input RoomCreateWithoutPropertyInput {
  name: String
  active: Boolean
  photos: RoomCreatephotosInput
  prices: PriceCreateManyInput
  beds: BedCreateManyWithoutRoomsInput
  facilities: FacilityCreateManyWithoutRoomsInput
  bookings: BookingCreateManyWithoutRoomsInput
}

"""An edge in a connection."""
type RoomEdge {
  """The item at the end of the edge."""
  node: Room!

  """A cursor for use in pagination."""
  cursor: String!
}

enum RoomOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  active_ASC
  active_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type RoomPreviousValues {
  id: ID!
  name: String
  photos: [String!]!
  active: Boolean
}

type RoomSubscriptionPayload {
  mutation: MutationType!
  node: Room
  updatedFields: [String!]
  previousValues: RoomPreviousValues
}

input RoomSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [RoomSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [RoomSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [RoomSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: RoomWhereInput
}

input RoomUpdateInput {
  name: String
  active: Boolean
  photos: RoomUpdatephotosInput
  property: PropertyUpdateOneWithoutRoomsInput
  prices: PriceUpdateManyInput
  beds: BedUpdateManyWithoutRoomsInput
  facilities: FacilityUpdateManyWithoutRoomsInput
  bookings: BookingUpdateManyWithoutRoomsInput
}

input RoomUpdateManyWithoutBedsInput {
  create: [RoomCreateWithoutBedsInput!]
  connect: [RoomWhereUniqueInput!]
  disconnect: [RoomWhereUniqueInput!]
  delete: [RoomWhereUniqueInput!]
  update: [RoomUpdateWithWhereUniqueWithoutBedsInput!]
  upsert: [RoomUpsertWithWhereUniqueWithoutBedsInput!]
}

input RoomUpdateManyWithoutBookingsInput {
  create: [RoomCreateWithoutBookingsInput!]
  connect: [RoomWhereUniqueInput!]
  disconnect: [RoomWhereUniqueInput!]
  delete: [RoomWhereUniqueInput!]
  update: [RoomUpdateWithWhereUniqueWithoutBookingsInput!]
  upsert: [RoomUpsertWithWhereUniqueWithoutBookingsInput!]
}

input RoomUpdateManyWithoutFacilitiesInput {
  create: [RoomCreateWithoutFacilitiesInput!]
  connect: [RoomWhereUniqueInput!]
  disconnect: [RoomWhereUniqueInput!]
  delete: [RoomWhereUniqueInput!]
  update: [RoomUpdateWithWhereUniqueWithoutFacilitiesInput!]
  upsert: [RoomUpsertWithWhereUniqueWithoutFacilitiesInput!]
}

input RoomUpdateManyWithoutPropertyInput {
  create: [RoomCreateWithoutPropertyInput!]
  connect: [RoomWhereUniqueInput!]
  disconnect: [RoomWhereUniqueInput!]
  delete: [RoomWhereUniqueInput!]
  update: [RoomUpdateWithWhereUniqueWithoutPropertyInput!]
  upsert: [RoomUpsertWithWhereUniqueWithoutPropertyInput!]
}

input RoomUpdatephotosInput {
  set: [String!]
}

input RoomUpdateWithoutBedsDataInput {
  name: String
  active: Boolean
  photos: RoomUpdatephotosInput
  property: PropertyUpdateOneWithoutRoomsInput
  prices: PriceUpdateManyInput
  facilities: FacilityUpdateManyWithoutRoomsInput
  bookings: BookingUpdateManyWithoutRoomsInput
}

input RoomUpdateWithoutBookingsDataInput {
  name: String
  active: Boolean
  photos: RoomUpdatephotosInput
  property: PropertyUpdateOneWithoutRoomsInput
  prices: PriceUpdateManyInput
  beds: BedUpdateManyWithoutRoomsInput
  facilities: FacilityUpdateManyWithoutRoomsInput
}

input RoomUpdateWithoutFacilitiesDataInput {
  name: String
  active: Boolean
  photos: RoomUpdatephotosInput
  property: PropertyUpdateOneWithoutRoomsInput
  prices: PriceUpdateManyInput
  beds: BedUpdateManyWithoutRoomsInput
  bookings: BookingUpdateManyWithoutRoomsInput
}

input RoomUpdateWithoutPropertyDataInput {
  name: String
  active: Boolean
  photos: RoomUpdatephotosInput
  prices: PriceUpdateManyInput
  beds: BedUpdateManyWithoutRoomsInput
  facilities: FacilityUpdateManyWithoutRoomsInput
  bookings: BookingUpdateManyWithoutRoomsInput
}

input RoomUpdateWithWhereUniqueWithoutBedsInput {
  where: RoomWhereUniqueInput!
  data: RoomUpdateWithoutBedsDataInput!
}

input RoomUpdateWithWhereUniqueWithoutBookingsInput {
  where: RoomWhereUniqueInput!
  data: RoomUpdateWithoutBookingsDataInput!
}

input RoomUpdateWithWhereUniqueWithoutFacilitiesInput {
  where: RoomWhereUniqueInput!
  data: RoomUpdateWithoutFacilitiesDataInput!
}

input RoomUpdateWithWhereUniqueWithoutPropertyInput {
  where: RoomWhereUniqueInput!
  data: RoomUpdateWithoutPropertyDataInput!
}

input RoomUpsertWithWhereUniqueWithoutBedsInput {
  where: RoomWhereUniqueInput!
  update: RoomUpdateWithoutBedsDataInput!
  create: RoomCreateWithoutBedsInput!
}

input RoomUpsertWithWhereUniqueWithoutBookingsInput {
  where: RoomWhereUniqueInput!
  update: RoomUpdateWithoutBookingsDataInput!
  create: RoomCreateWithoutBookingsInput!
}

input RoomUpsertWithWhereUniqueWithoutFacilitiesInput {
  where: RoomWhereUniqueInput!
  update: RoomUpdateWithoutFacilitiesDataInput!
  create: RoomCreateWithoutFacilitiesInput!
}

input RoomUpsertWithWhereUniqueWithoutPropertyInput {
  where: RoomWhereUniqueInput!
  update: RoomUpdateWithoutPropertyDataInput!
  create: RoomCreateWithoutPropertyInput!
}

input RoomWhereInput {
  """Logical AND on all given filters."""
  AND: [RoomWhereInput!]

  """Logical OR on all given filters."""
  OR: [RoomWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [RoomWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  active: Boolean

  """All values that are not equal to given value."""
  active_not: Boolean
  property: PropertyWhereInput
  prices_every: PriceWhereInput
  prices_some: PriceWhereInput
  prices_none: PriceWhereInput
  beds_every: BedWhereInput
  beds_some: BedWhereInput
  beds_none: BedWhereInput
  facilities_every: FacilityWhereInput
  facilities_some: FacilityWhereInput
  facilities_none: FacilityWhereInput
  bookings_every: BookingWhereInput
  bookings_some: BookingWhereInput
  bookings_none: BookingWhereInput
}

input RoomWhereUniqueInput {
  id: ID
}

enum Status {
  PAID
  PAY_AT_CHECKOUT
  WAIVED
}

type Subscription {
  customer(where: CustomerSubscriptionWhereInput): CustomerSubscriptionPayload
  property(where: PropertySubscriptionWhereInput): PropertySubscriptionPayload
  category(where: CategorySubscriptionWhereInput): CategorySubscriptionPayload
  room(where: RoomSubscriptionWhereInput): RoomSubscriptionPayload
  bed(where: BedSubscriptionWhereInput): BedSubscriptionPayload
  bedType(where: BedTypeSubscriptionWhereInput): BedTypeSubscriptionPayload
  facility(where: FacilitySubscriptionWhereInput): FacilitySubscriptionPayload
  propertyFacility(where: PropertyFacilitySubscriptionWhereInput): PropertyFacilitySubscriptionPayload
  facilityType(where: FacilityTypeSubscriptionWhereInput): FacilityTypeSubscriptionPayload
  policy(where: PolicySubscriptionWhereInput): PolicySubscriptionPayload
  review(where: ReviewSubscriptionWhereInput): ReviewSubscriptionPayload
  order(where: OrderSubscriptionWhereInput): OrderSubscriptionPayload
  timezone(where: TimezoneSubscriptionWhereInput): TimezoneSubscriptionPayload
  language(where: LanguageSubscriptionWhereInput): LanguageSubscriptionPayload
  preference(where: PreferenceSubscriptionWhereInput): PreferenceSubscriptionPayload
  tax(where: TaxSubscriptionWhereInput): TaxSubscriptionPayload
  promo(where: PromoSubscriptionWhereInput): PromoSubscriptionPayload
  booking(where: BookingSubscriptionWhereInput): BookingSubscriptionPayload
  country(where: CountrySubscriptionWhereInput): CountrySubscriptionPayload
  address(where: AddressSubscriptionWhereInput): AddressSubscriptionPayload
  priceType(where: PriceTypeSubscriptionWhereInput): PriceTypeSubscriptionPayload
  price(where: PriceSubscriptionWhereInput): PriceSubscriptionPayload
  currency(where: CurrencySubscriptionWhereInput): CurrencySubscriptionPayload
}

type Tax implements Node {
  id: ID!
  name: String!
  description: String
  percent: Float!
}

"""A connection to a list of items."""
type TaxConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [TaxEdge]!
  aggregate: AggregateTax!
}

input TaxCreateInput {
  name: String!
  description: String
  percent: Float!
}

input TaxCreateManyInput {
  create: [TaxCreateInput!]
  connect: [TaxWhereUniqueInput!]
}

"""An edge in a connection."""
type TaxEdge {
  """The item at the end of the edge."""
  node: Tax!

  """A cursor for use in pagination."""
  cursor: String!
}

enum TaxOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  percent_ASC
  percent_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type TaxPreviousValues {
  id: ID!
  name: String!
  description: String
  percent: Float!
}

type TaxSubscriptionPayload {
  mutation: MutationType!
  node: Tax
  updatedFields: [String!]
  previousValues: TaxPreviousValues
}

input TaxSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [TaxSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [TaxSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [TaxSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: TaxWhereInput
}

input TaxUpdateDataInput {
  name: String
  description: String
  percent: Float
}

input TaxUpdateInput {
  name: String
  description: String
  percent: Float
}

input TaxUpdateManyInput {
  create: [TaxCreateInput!]
  connect: [TaxWhereUniqueInput!]
  disconnect: [TaxWhereUniqueInput!]
  delete: [TaxWhereUniqueInput!]
  update: [TaxUpdateWithWhereUniqueNestedInput!]
  upsert: [TaxUpsertWithWhereUniqueNestedInput!]
}

input TaxUpdateWithWhereUniqueNestedInput {
  where: TaxWhereUniqueInput!
  data: TaxUpdateDataInput!
}

input TaxUpsertWithWhereUniqueNestedInput {
  where: TaxWhereUniqueInput!
  update: TaxUpdateDataInput!
  create: TaxCreateInput!
}

input TaxWhereInput {
  """Logical AND on all given filters."""
  AND: [TaxWhereInput!]

  """Logical OR on all given filters."""
  OR: [TaxWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [TaxWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  description: String

  """All values that are not equal to given value."""
  description_not: String

  """All values that are contained in given list."""
  description_in: [String!]

  """All values that are not contained in given list."""
  description_not_in: [String!]

  """All values less than the given value."""
  description_lt: String

  """All values less than or equal the given value."""
  description_lte: String

  """All values greater than the given value."""
  description_gt: String

  """All values greater than or equal the given value."""
  description_gte: String

  """All values containing the given string."""
  description_contains: String

  """All values not containing the given string."""
  description_not_contains: String

  """All values starting with the given string."""
  description_starts_with: String

  """All values not starting with the given string."""
  description_not_starts_with: String

  """All values ending with the given string."""
  description_ends_with: String

  """All values not ending with the given string."""
  description_not_ends_with: String
  percent: Float

  """All values that are not equal to given value."""
  percent_not: Float

  """All values that are contained in given list."""
  percent_in: [Float!]

  """All values that are not contained in given list."""
  percent_not_in: [Float!]

  """All values less than the given value."""
  percent_lt: Float

  """All values less than or equal the given value."""
  percent_lte: Float

  """All values greater than the given value."""
  percent_gt: Float

  """All values greater than or equal the given value."""
  percent_gte: Float
  _MagicalBackRelation_OrderToTax_every: OrderWhereInput
  _MagicalBackRelation_OrderToTax_some: OrderWhereInput
  _MagicalBackRelation_OrderToTax_none: OrderWhereInput
}

input TaxWhereUniqueInput {
  id: ID
}

type Timezone implements Node {
  id: ID!
  name: String!
  current_time: String!
  code: String
  isDaylightSaving: Boolean
  country(where: CountryWhereInput): Country!
}

"""A connection to a list of items."""
type TimezoneConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [TimezoneEdge]!
  aggregate: AggregateTimezone!
}

input TimezoneCreateInput {
  name: String!
  current_time: String!
  code: String
  isDaylightSaving: Boolean
  country: CountryCreateOneWithoutTimezoneInput!
}

input TimezoneCreateOneWithoutCountryInput {
  create: TimezoneCreateWithoutCountryInput
  connect: TimezoneWhereUniqueInput
}

input TimezoneCreateWithoutCountryInput {
  name: String!
  current_time: String!
  code: String
  isDaylightSaving: Boolean
}

"""An edge in a connection."""
type TimezoneEdge {
  """The item at the end of the edge."""
  node: Timezone!

  """A cursor for use in pagination."""
  cursor: String!
}

enum TimezoneOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  current_time_ASC
  current_time_DESC
  code_ASC
  code_DESC
  isDaylightSaving_ASC
  isDaylightSaving_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type TimezonePreviousValues {
  id: ID!
  name: String!
  current_time: String!
  code: String
  isDaylightSaving: Boolean
}

type TimezoneSubscriptionPayload {
  mutation: MutationType!
  node: Timezone
  updatedFields: [String!]
  previousValues: TimezonePreviousValues
}

input TimezoneSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [TimezoneSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [TimezoneSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [TimezoneSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: TimezoneWhereInput
}

input TimezoneUpdateInput {
  name: String
  current_time: String
  code: String
  isDaylightSaving: Boolean
  country: CountryUpdateOneWithoutTimezoneInput
}

input TimezoneUpdateOneWithoutCountryInput {
  create: TimezoneCreateWithoutCountryInput
  connect: TimezoneWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: TimezoneUpdateWithoutCountryDataInput
  upsert: TimezoneUpsertWithoutCountryInput
}

input TimezoneUpdateWithoutCountryDataInput {
  name: String
  current_time: String
  code: String
  isDaylightSaving: Boolean
}

input TimezoneUpsertWithoutCountryInput {
  update: TimezoneUpdateWithoutCountryDataInput!
  create: TimezoneCreateWithoutCountryInput!
}

input TimezoneWhereInput {
  """Logical AND on all given filters."""
  AND: [TimezoneWhereInput!]

  """Logical OR on all given filters."""
  OR: [TimezoneWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [TimezoneWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  current_time: String

  """All values that are not equal to given value."""
  current_time_not: String

  """All values that are contained in given list."""
  current_time_in: [String!]

  """All values that are not contained in given list."""
  current_time_not_in: [String!]

  """All values less than the given value."""
  current_time_lt: String

  """All values less than or equal the given value."""
  current_time_lte: String

  """All values greater than the given value."""
  current_time_gt: String

  """All values greater than or equal the given value."""
  current_time_gte: String

  """All values containing the given string."""
  current_time_contains: String

  """All values not containing the given string."""
  current_time_not_contains: String

  """All values starting with the given string."""
  current_time_starts_with: String

  """All values not starting with the given string."""
  current_time_not_starts_with: String

  """All values ending with the given string."""
  current_time_ends_with: String

  """All values not ending with the given string."""
  current_time_not_ends_with: String
  code: String

  """All values that are not equal to given value."""
  code_not: String

  """All values that are contained in given list."""
  code_in: [String!]

  """All values that are not contained in given list."""
  code_not_in: [String!]

  """All values less than the given value."""
  code_lt: String

  """All values less than or equal the given value."""
  code_lte: String

  """All values greater than the given value."""
  code_gt: String

  """All values greater than or equal the given value."""
  code_gte: String

  """All values containing the given string."""
  code_contains: String

  """All values not containing the given string."""
  code_not_contains: String

  """All values starting with the given string."""
  code_starts_with: String

  """All values not starting with the given string."""
  code_not_starts_with: String

  """All values ending with the given string."""
  code_ends_with: String

  """All values not ending with the given string."""
  code_not_ends_with: String
  isDaylightSaving: Boolean

  """All values that are not equal to given value."""
  isDaylightSaving_not: Boolean
  country: CountryWhereInput
}

input TimezoneWhereUniqueInput {
  id: ID
  name: String
}

enum Unit {
  PERCENT
  NZD
  INR
  USD
}
